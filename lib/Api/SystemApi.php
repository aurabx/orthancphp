<?php
/**
 * SystemApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Aurabx\OrthancPHP
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://orthanc.uclouvain.be/book/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://orthanc.uclouvain.be/book/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.12.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Aurabx\OrthancPHP\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aurabx\OrthancPHP\ApiException;
use Aurabx\OrthancPHP\Configuration;
use Aurabx\OrthancPHP\HeaderSelector;
use Aurabx\OrthancPHP\ObjectSerializer;

/**
 * SystemApi Class Doc Comment
 *
 * @category Class
 * @package  Aurabx\OrthancPHP
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SystemApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'pluginsExplorerJsGet' => [
            'application/json',
        ],
        'pluginsGet' => [
            'application/json',
        ],
        'pluginsIdGet' => [
            'application/json',
        ],
        'statisticsGet' => [
            'application/json',
        ],
        'systemGet' => [
            'application/json',
        ],
        'toolsAcceptedTransferSyntaxesGet' => [
            'application/json',
        ],
        'toolsAcceptedTransferSyntaxesPut' => [
            'application/json',
            'text/plain',
        ],
        'toolsBulkAnonymizePost' => [
            'application/json',
        ],
        'toolsBulkContentPost' => [
            'application/json',
        ],
        'toolsBulkDeletePost' => [
            'application/json',
        ],
        'toolsBulkModifyPost' => [
            'application/json',
        ],
        'toolsCreateArchiveGet' => [
            'application/json',
        ],
        'toolsCreateArchivePost' => [
            'application/json',
        ],
        'toolsCreateDicomPost' => [
            'application/json',
        ],
        'toolsCreateMediaExtendedGet' => [
            'application/json',
        ],
        'toolsCreateMediaExtendedPost' => [
            'application/json',
        ],
        'toolsCreateMediaGet' => [
            'application/json',
        ],
        'toolsCreateMediaPost' => [
            'application/json',
        ],
        'toolsDefaultEncodingGet' => [
            'application/json',
        ],
        'toolsDefaultEncodingPut' => [
            'text/plain',
        ],
        'toolsDicomConformanceGet' => [
            'application/json',
        ],
        'toolsDicomEchoPost' => [
            'application/json',
        ],
        'toolsExecuteScriptPost' => [
            'text/plain',
        ],
        'toolsFindPost' => [
            'application/json',
        ],
        'toolsGenerateUidGet' => [
            'application/json',
        ],
        'toolsInvalidateTagsPost' => [
            'application/json',
        ],
        'toolsLabelsGet' => [
            'application/json',
        ],
        'toolsLookupPost' => [
            'text/plain',
        ],
        'toolsMetricsGet' => [
            'application/json',
        ],
        'toolsMetricsPrometheusGet' => [
            'application/json',
        ],
        'toolsMetricsPut' => [
            'text/plain',
        ],
        'toolsNowGet' => [
            'application/json',
        ],
        'toolsNowLocalGet' => [
            'application/json',
        ],
        'toolsReconstructPost' => [
            'application/json',
        ],
        'toolsResetPost' => [
            'application/json',
        ],
        'toolsShutdownPost' => [
            'application/json',
        ],
        'toolsUnknownSopClassAcceptedGet' => [
            'application/json',
        ],
        'toolsUnknownSopClassAcceptedPut' => [
            'text/plain',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation pluginsExplorerJsGet
     *
     * JavaScript extensions to Orthanc Explorer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsExplorerJsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function pluginsExplorerJsGet(string $contentType = self::contentTypes['pluginsExplorerJsGet'][0])
    {
        list($response) = $this->pluginsExplorerJsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation pluginsExplorerJsGetWithHttpInfo
     *
     * JavaScript extensions to Orthanc Explorer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsExplorerJsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function pluginsExplorerJsGetWithHttpInfo(string $contentType = self::contentTypes['pluginsExplorerJsGet'][0])
    {
        $request = $this->pluginsExplorerJsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pluginsExplorerJsGetAsync
     *
     * JavaScript extensions to Orthanc Explorer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsExplorerJsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pluginsExplorerJsGetAsync(string $contentType = self::contentTypes['pluginsExplorerJsGet'][0])
    {
        return $this->pluginsExplorerJsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pluginsExplorerJsGetAsyncWithHttpInfo
     *
     * JavaScript extensions to Orthanc Explorer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsExplorerJsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pluginsExplorerJsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['pluginsExplorerJsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->pluginsExplorerJsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pluginsExplorerJsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsExplorerJsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pluginsExplorerJsGetRequest(string $contentType = self::contentTypes['pluginsExplorerJsGet'][0])
    {


        $resourcePath = '/plugins/explorer.js';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/javascript', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pluginsGet
     *
     * List plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function pluginsGet(string $contentType = self::contentTypes['pluginsGet'][0])
    {
        list($response) = $this->pluginsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation pluginsGetWithHttpInfo
     *
     * List plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function pluginsGetWithHttpInfo(string $contentType = self::contentTypes['pluginsGet'][0])
    {
        $request = $this->pluginsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pluginsGetAsync
     *
     * List plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pluginsGetAsync(string $contentType = self::contentTypes['pluginsGet'][0])
    {
        return $this->pluginsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pluginsGetAsyncWithHttpInfo
     *
     * List plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pluginsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['pluginsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->pluginsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pluginsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pluginsGetRequest(string $contentType = self::contentTypes['pluginsGet'][0])
    {


        $resourcePath = '/plugins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pluginsIdGet
     *
     * Get plugin
     *
     * @param  string $id Identifier of the job of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function pluginsIdGet($id, string $contentType = self::contentTypes['pluginsIdGet'][0])
    {
        list($response) = $this->pluginsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation pluginsIdGetWithHttpInfo
     *
     * Get plugin
     *
     * @param  string $id Identifier of the job of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function pluginsIdGetWithHttpInfo($id, string $contentType = self::contentTypes['pluginsIdGet'][0])
    {
        $request = $this->pluginsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pluginsIdGetAsync
     *
     * Get plugin
     *
     * @param  string $id Identifier of the job of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pluginsIdGetAsync($id, string $contentType = self::contentTypes['pluginsIdGet'][0])
    {
        return $this->pluginsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pluginsIdGetAsyncWithHttpInfo
     *
     * Get plugin
     *
     * @param  string $id Identifier of the job of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pluginsIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['pluginsIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->pluginsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pluginsIdGet'
     *
     * @param  string $id Identifier of the job of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pluginsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pluginsIdGetRequest($id, string $contentType = self::contentTypes['pluginsIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pluginsIdGet'
            );
        }


        $resourcePath = '/plugins/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation statisticsGet
     *
     * Get database statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statisticsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\StatisticsGet200Response
     */
    public function statisticsGet(string $contentType = self::contentTypes['statisticsGet'][0])
    {
        list($response) = $this->statisticsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation statisticsGetWithHttpInfo
     *
     * Get database statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statisticsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\StatisticsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function statisticsGetWithHttpInfo(string $contentType = self::contentTypes['statisticsGet'][0])
    {
        $request = $this->statisticsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\StatisticsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\StatisticsGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\StatisticsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\StatisticsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\StatisticsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation statisticsGetAsync
     *
     * Get database statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function statisticsGetAsync(string $contentType = self::contentTypes['statisticsGet'][0])
    {
        return $this->statisticsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation statisticsGetAsyncWithHttpInfo
     *
     * Get database statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function statisticsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['statisticsGet'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\StatisticsGet200Response';
        $request = $this->statisticsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'statisticsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function statisticsGetRequest(string $contentType = self::contentTypes['statisticsGet'][0])
    {


        $resourcePath = '/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation systemGet
     *
     * Get system information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['systemGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\SystemGet200Response
     */
    public function systemGet(string $contentType = self::contentTypes['systemGet'][0])
    {
        list($response) = $this->systemGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation systemGetWithHttpInfo
     *
     * Get system information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['systemGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\SystemGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemGetWithHttpInfo(string $contentType = self::contentTypes['systemGet'][0])
    {
        $request = $this->systemGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\SystemGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\SystemGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\SystemGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\SystemGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\SystemGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemGetAsync
     *
     * Get system information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['systemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemGetAsync(string $contentType = self::contentTypes['systemGet'][0])
    {
        return $this->systemGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemGetAsyncWithHttpInfo
     *
     * Get system information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['systemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function systemGetAsyncWithHttpInfo(string $contentType = self::contentTypes['systemGet'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\SystemGet200Response';
        $request = $this->systemGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['systemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function systemGetRequest(string $contentType = self::contentTypes['systemGet'][0])
    {


        $resourcePath = '/system';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesGet
     *
     * Get accepted transfer syntaxes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsAcceptedTransferSyntaxesGet(string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesGet'][0])
    {
        list($response) = $this->toolsAcceptedTransferSyntaxesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesGetWithHttpInfo
     *
     * Get accepted transfer syntaxes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsAcceptedTransferSyntaxesGetWithHttpInfo(string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesGet'][0])
    {
        $request = $this->toolsAcceptedTransferSyntaxesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesGetAsync
     *
     * Get accepted transfer syntaxes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsAcceptedTransferSyntaxesGetAsync(string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesGet'][0])
    {
        return $this->toolsAcceptedTransferSyntaxesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesGetAsyncWithHttpInfo
     *
     * Get accepted transfer syntaxes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsAcceptedTransferSyntaxesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsAcceptedTransferSyntaxesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsAcceptedTransferSyntaxesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsAcceptedTransferSyntaxesGetRequest(string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesGet'][0])
    {


        $resourcePath = '/tools/accepted-transfer-syntaxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesPut
     *
     * Set accepted transfer syntaxes
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsAcceptedTransferSyntaxesPut($body = null, string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesPut'][0])
    {
        list($response) = $this->toolsAcceptedTransferSyntaxesPutWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesPutWithHttpInfo
     *
     * Set accepted transfer syntaxes
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsAcceptedTransferSyntaxesPutWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesPut'][0])
    {
        $request = $this->toolsAcceptedTransferSyntaxesPutRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesPutAsync
     *
     * Set accepted transfer syntaxes
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsAcceptedTransferSyntaxesPutAsync($body = null, string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesPut'][0])
    {
        return $this->toolsAcceptedTransferSyntaxesPutAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsAcceptedTransferSyntaxesPutAsyncWithHttpInfo
     *
     * Set accepted transfer syntaxes
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsAcceptedTransferSyntaxesPutAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesPut'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsAcceptedTransferSyntaxesPutRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsAcceptedTransferSyntaxesPut'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsAcceptedTransferSyntaxesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsAcceptedTransferSyntaxesPutRequest($body = null, string $contentType = self::contentTypes['toolsAcceptedTransferSyntaxesPut'][0])
    {



        $resourcePath = '/tools/accepted-transfer-syntaxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsBulkAnonymizePost
     *
     * Anonymize a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePostRequest $toolsBulkAnonymizePostRequest toolsBulkAnonymizePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkAnonymizePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response
     */
    public function toolsBulkAnonymizePost($toolsBulkAnonymizePostRequest = null, string $contentType = self::contentTypes['toolsBulkAnonymizePost'][0])
    {
        list($response) = $this->toolsBulkAnonymizePostWithHttpInfo($toolsBulkAnonymizePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsBulkAnonymizePostWithHttpInfo
     *
     * Anonymize a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePostRequest $toolsBulkAnonymizePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkAnonymizePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsBulkAnonymizePostWithHttpInfo($toolsBulkAnonymizePostRequest = null, string $contentType = self::contentTypes['toolsBulkAnonymizePost'][0])
    {
        $request = $this->toolsBulkAnonymizePostRequest($toolsBulkAnonymizePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsBulkAnonymizePostAsync
     *
     * Anonymize a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePostRequest $toolsBulkAnonymizePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkAnonymizePostAsync($toolsBulkAnonymizePostRequest = null, string $contentType = self::contentTypes['toolsBulkAnonymizePost'][0])
    {
        return $this->toolsBulkAnonymizePostAsyncWithHttpInfo($toolsBulkAnonymizePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsBulkAnonymizePostAsyncWithHttpInfo
     *
     * Anonymize a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePostRequest $toolsBulkAnonymizePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkAnonymizePostAsyncWithHttpInfo($toolsBulkAnonymizePostRequest = null, string $contentType = self::contentTypes['toolsBulkAnonymizePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePost200Response';
        $request = $this->toolsBulkAnonymizePostRequest($toolsBulkAnonymizePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsBulkAnonymizePost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkAnonymizePostRequest $toolsBulkAnonymizePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsBulkAnonymizePostRequest($toolsBulkAnonymizePostRequest = null, string $contentType = self::contentTypes['toolsBulkAnonymizePost'][0])
    {



        $resourcePath = '/tools/bulk-anonymize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsBulkAnonymizePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsBulkAnonymizePostRequest));
            } else {
                $httpBody = $toolsBulkAnonymizePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsBulkContentPost
     *
     * Describe a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkContentPostRequest $toolsBulkContentPostRequest toolsBulkContentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkContentPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsBulkContentPost($toolsBulkContentPostRequest = null, string $contentType = self::contentTypes['toolsBulkContentPost'][0])
    {
        $this->toolsBulkContentPostWithHttpInfo($toolsBulkContentPostRequest, $contentType);
    }

    /**
     * Operation toolsBulkContentPostWithHttpInfo
     *
     * Describe a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkContentPostRequest $toolsBulkContentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkContentPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsBulkContentPostWithHttpInfo($toolsBulkContentPostRequest = null, string $contentType = self::contentTypes['toolsBulkContentPost'][0])
    {
        $request = $this->toolsBulkContentPostRequest($toolsBulkContentPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsBulkContentPostAsync
     *
     * Describe a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkContentPostRequest $toolsBulkContentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkContentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkContentPostAsync($toolsBulkContentPostRequest = null, string $contentType = self::contentTypes['toolsBulkContentPost'][0])
    {
        return $this->toolsBulkContentPostAsyncWithHttpInfo($toolsBulkContentPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsBulkContentPostAsyncWithHttpInfo
     *
     * Describe a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkContentPostRequest $toolsBulkContentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkContentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkContentPostAsyncWithHttpInfo($toolsBulkContentPostRequest = null, string $contentType = self::contentTypes['toolsBulkContentPost'][0])
    {
        $returnType = '';
        $request = $this->toolsBulkContentPostRequest($toolsBulkContentPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsBulkContentPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkContentPostRequest $toolsBulkContentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkContentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsBulkContentPostRequest($toolsBulkContentPostRequest = null, string $contentType = self::contentTypes['toolsBulkContentPost'][0])
    {



        $resourcePath = '/tools/bulk-content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsBulkContentPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsBulkContentPostRequest));
            } else {
                $httpBody = $toolsBulkContentPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsBulkDeletePost
     *
     * Delete a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkDeletePostRequest $toolsBulkDeletePostRequest toolsBulkDeletePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkDeletePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsBulkDeletePost($toolsBulkDeletePostRequest = null, string $contentType = self::contentTypes['toolsBulkDeletePost'][0])
    {
        $this->toolsBulkDeletePostWithHttpInfo($toolsBulkDeletePostRequest, $contentType);
    }

    /**
     * Operation toolsBulkDeletePostWithHttpInfo
     *
     * Delete a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkDeletePostRequest $toolsBulkDeletePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkDeletePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsBulkDeletePostWithHttpInfo($toolsBulkDeletePostRequest = null, string $contentType = self::contentTypes['toolsBulkDeletePost'][0])
    {
        $request = $this->toolsBulkDeletePostRequest($toolsBulkDeletePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsBulkDeletePostAsync
     *
     * Delete a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkDeletePostRequest $toolsBulkDeletePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkDeletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkDeletePostAsync($toolsBulkDeletePostRequest = null, string $contentType = self::contentTypes['toolsBulkDeletePost'][0])
    {
        return $this->toolsBulkDeletePostAsyncWithHttpInfo($toolsBulkDeletePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsBulkDeletePostAsyncWithHttpInfo
     *
     * Delete a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkDeletePostRequest $toolsBulkDeletePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkDeletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkDeletePostAsyncWithHttpInfo($toolsBulkDeletePostRequest = null, string $contentType = self::contentTypes['toolsBulkDeletePost'][0])
    {
        $returnType = '';
        $request = $this->toolsBulkDeletePostRequest($toolsBulkDeletePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsBulkDeletePost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkDeletePostRequest $toolsBulkDeletePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkDeletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsBulkDeletePostRequest($toolsBulkDeletePostRequest = null, string $contentType = self::contentTypes['toolsBulkDeletePost'][0])
    {



        $resourcePath = '/tools/bulk-delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsBulkDeletePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsBulkDeletePostRequest));
            } else {
                $httpBody = $toolsBulkDeletePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsBulkModifyPost
     *
     * Modify a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkModifyPostRequest $toolsBulkModifyPostRequest toolsBulkModifyPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkModifyPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response
     */
    public function toolsBulkModifyPost($toolsBulkModifyPostRequest = null, string $contentType = self::contentTypes['toolsBulkModifyPost'][0])
    {
        list($response) = $this->toolsBulkModifyPostWithHttpInfo($toolsBulkModifyPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsBulkModifyPostWithHttpInfo
     *
     * Modify a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkModifyPostRequest $toolsBulkModifyPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkModifyPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsBulkModifyPostWithHttpInfo($toolsBulkModifyPostRequest = null, string $contentType = self::contentTypes['toolsBulkModifyPost'][0])
    {
        $request = $this->toolsBulkModifyPostRequest($toolsBulkModifyPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsBulkModifyPostAsync
     *
     * Modify a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkModifyPostRequest $toolsBulkModifyPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkModifyPostAsync($toolsBulkModifyPostRequest = null, string $contentType = self::contentTypes['toolsBulkModifyPost'][0])
    {
        return $this->toolsBulkModifyPostAsyncWithHttpInfo($toolsBulkModifyPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsBulkModifyPostAsyncWithHttpInfo
     *
     * Modify a set of resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkModifyPostRequest $toolsBulkModifyPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsBulkModifyPostAsyncWithHttpInfo($toolsBulkModifyPostRequest = null, string $contentType = self::contentTypes['toolsBulkModifyPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ToolsBulkModifyPost200Response';
        $request = $this->toolsBulkModifyPostRequest($toolsBulkModifyPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsBulkModifyPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsBulkModifyPostRequest $toolsBulkModifyPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsBulkModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsBulkModifyPostRequest($toolsBulkModifyPostRequest = null, string $contentType = self::contentTypes['toolsBulkModifyPost'][0])
    {



        $resourcePath = '/tools/bulk-modify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsBulkModifyPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsBulkModifyPostRequest));
            } else {
                $httpBody = $toolsBulkModifyPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateArchiveGet
     *
     * Create ZIP archive
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the ZIP archive. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchiveGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsCreateArchiveGet($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateArchiveGet'][0])
    {
        $this->toolsCreateArchiveGetWithHttpInfo($resources, $transcode, $contentType);
    }

    /**
     * Operation toolsCreateArchiveGetWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the ZIP archive. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchiveGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateArchiveGetWithHttpInfo($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateArchiveGet'][0])
    {
        $request = $this->toolsCreateArchiveGetRequest($resources, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateArchiveGetAsync
     *
     * Create ZIP archive
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the ZIP archive. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateArchiveGetAsync($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateArchiveGet'][0])
    {
        return $this->toolsCreateArchiveGetAsyncWithHttpInfo($resources, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateArchiveGetAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the ZIP archive. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateArchiveGetAsyncWithHttpInfo($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateArchiveGet'][0])
    {
        $returnType = '';
        $request = $this->toolsCreateArchiveGetRequest($resources, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateArchiveGet'
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the ZIP archive. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateArchiveGetRequest($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateArchiveGet'][0])
    {

        // verify the required parameter 'resources' is set
        if ($resources === null || (is_array($resources) && count($resources) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resources when calling toolsCreateArchiveGet'
            );
        }



        $resourcePath = '/tools/create-archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resources,
            'resources', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateArchivePost
     *
     * Create ZIP archive
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateArchivePostRequest $toolsCreateArchivePostRequest toolsCreateArchivePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchivePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response
     */
    public function toolsCreateArchivePost($toolsCreateArchivePostRequest = null, string $contentType = self::contentTypes['toolsCreateArchivePost'][0])
    {
        list($response) = $this->toolsCreateArchivePostWithHttpInfo($toolsCreateArchivePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsCreateArchivePostWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateArchivePostRequest $toolsCreateArchivePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchivePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateArchivePostWithHttpInfo($toolsCreateArchivePostRequest = null, string $contentType = self::contentTypes['toolsCreateArchivePost'][0])
    {
        $request = $this->toolsCreateArchivePostRequest($toolsCreateArchivePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateArchivePostAsync
     *
     * Create ZIP archive
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateArchivePostRequest $toolsCreateArchivePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateArchivePostAsync($toolsCreateArchivePostRequest = null, string $contentType = self::contentTypes['toolsCreateArchivePost'][0])
    {
        return $this->toolsCreateArchivePostAsyncWithHttpInfo($toolsCreateArchivePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateArchivePostAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateArchivePostRequest $toolsCreateArchivePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateArchivePostAsyncWithHttpInfo($toolsCreateArchivePostRequest = null, string $contentType = self::contentTypes['toolsCreateArchivePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response';
        $request = $this->toolsCreateArchivePostRequest($toolsCreateArchivePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateArchivePost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateArchivePostRequest $toolsCreateArchivePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateArchivePostRequest($toolsCreateArchivePostRequest = null, string $contentType = self::contentTypes['toolsCreateArchivePost'][0])
    {



        $resourcePath = '/tools/create-archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsCreateArchivePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsCreateArchivePostRequest));
            } else {
                $httpBody = $toolsCreateArchivePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateDicomPost
     *
     * Create one DICOM instance
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateDicomPostRequest $toolsCreateDicomPostRequest toolsCreateDicomPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateDicomPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response
     */
    public function toolsCreateDicomPost($toolsCreateDicomPostRequest = null, string $contentType = self::contentTypes['toolsCreateDicomPost'][0])
    {
        list($response) = $this->toolsCreateDicomPostWithHttpInfo($toolsCreateDicomPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsCreateDicomPostWithHttpInfo
     *
     * Create one DICOM instance
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateDicomPostRequest $toolsCreateDicomPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateDicomPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateDicomPostWithHttpInfo($toolsCreateDicomPostRequest = null, string $contentType = self::contentTypes['toolsCreateDicomPost'][0])
    {
        $request = $this->toolsCreateDicomPostRequest($toolsCreateDicomPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateDicomPostAsync
     *
     * Create one DICOM instance
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateDicomPostRequest $toolsCreateDicomPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateDicomPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateDicomPostAsync($toolsCreateDicomPostRequest = null, string $contentType = self::contentTypes['toolsCreateDicomPost'][0])
    {
        return $this->toolsCreateDicomPostAsyncWithHttpInfo($toolsCreateDicomPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateDicomPostAsyncWithHttpInfo
     *
     * Create one DICOM instance
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateDicomPostRequest $toolsCreateDicomPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateDicomPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateDicomPostAsyncWithHttpInfo($toolsCreateDicomPostRequest = null, string $contentType = self::contentTypes['toolsCreateDicomPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ToolsCreateDicomPost200Response';
        $request = $this->toolsCreateDicomPostRequest($toolsCreateDicomPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateDicomPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateDicomPostRequest $toolsCreateDicomPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateDicomPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateDicomPostRequest($toolsCreateDicomPostRequest = null, string $contentType = self::contentTypes['toolsCreateDicomPost'][0])
    {



        $resourcePath = '/tools/create-dicom';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsCreateDicomPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsCreateDicomPostRequest));
            } else {
                $httpBody = $toolsCreateDicomPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateMediaExtendedGet
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsCreateMediaExtendedGet($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedGet'][0])
    {
        $this->toolsCreateMediaExtendedGetWithHttpInfo($resources, $transcode, $contentType);
    }

    /**
     * Operation toolsCreateMediaExtendedGetWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateMediaExtendedGetWithHttpInfo($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedGet'][0])
    {
        $request = $this->toolsCreateMediaExtendedGetRequest($resources, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateMediaExtendedGetAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaExtendedGetAsync($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedGet'][0])
    {
        return $this->toolsCreateMediaExtendedGetAsyncWithHttpInfo($resources, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateMediaExtendedGetAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaExtendedGetAsyncWithHttpInfo($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedGet'][0])
    {
        $returnType = '';
        $request = $this->toolsCreateMediaExtendedGetRequest($resources, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateMediaExtendedGet'
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateMediaExtendedGetRequest($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedGet'][0])
    {

        // verify the required parameter 'resources' is set
        if ($resources === null || (is_array($resources) && count($resources) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resources when calling toolsCreateMediaExtendedGet'
            );
        }



        $resourcePath = '/tools/create-media-extended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resources,
            'resources', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateMediaExtendedPost
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaExtendedPostRequest $toolsCreateMediaExtendedPostRequest toolsCreateMediaExtendedPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response
     */
    public function toolsCreateMediaExtendedPost($toolsCreateMediaExtendedPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedPost'][0])
    {
        list($response) = $this->toolsCreateMediaExtendedPostWithHttpInfo($toolsCreateMediaExtendedPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsCreateMediaExtendedPostWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaExtendedPostRequest $toolsCreateMediaExtendedPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateMediaExtendedPostWithHttpInfo($toolsCreateMediaExtendedPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedPost'][0])
    {
        $request = $this->toolsCreateMediaExtendedPostRequest($toolsCreateMediaExtendedPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateMediaExtendedPostAsync
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaExtendedPostRequest $toolsCreateMediaExtendedPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaExtendedPostAsync($toolsCreateMediaExtendedPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedPost'][0])
    {
        return $this->toolsCreateMediaExtendedPostAsyncWithHttpInfo($toolsCreateMediaExtendedPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateMediaExtendedPostAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaExtendedPostRequest $toolsCreateMediaExtendedPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaExtendedPostAsyncWithHttpInfo($toolsCreateMediaExtendedPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response';
        $request = $this->toolsCreateMediaExtendedPostRequest($toolsCreateMediaExtendedPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateMediaExtendedPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaExtendedPostRequest $toolsCreateMediaExtendedPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaExtendedPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateMediaExtendedPostRequest($toolsCreateMediaExtendedPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaExtendedPost'][0])
    {



        $resourcePath = '/tools/create-media-extended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsCreateMediaExtendedPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsCreateMediaExtendedPostRequest));
            } else {
                $httpBody = $toolsCreateMediaExtendedPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateMediaGet
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsCreateMediaGet($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaGet'][0])
    {
        $this->toolsCreateMediaGetWithHttpInfo($resources, $transcode, $contentType);
    }

    /**
     * Operation toolsCreateMediaGetWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateMediaGetWithHttpInfo($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaGet'][0])
    {
        $request = $this->toolsCreateMediaGetRequest($resources, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateMediaGetAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaGetAsync($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaGet'][0])
    {
        return $this->toolsCreateMediaGetAsyncWithHttpInfo($resources, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateMediaGetAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaGetAsyncWithHttpInfo($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaGet'][0])
    {
        $returnType = '';
        $request = $this->toolsCreateMediaGetRequest($resources, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateMediaGet'
     *
     * @param  string $resources A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media. (required)
     * @param  string $transcode If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateMediaGetRequest($resources, $transcode = null, string $contentType = self::contentTypes['toolsCreateMediaGet'][0])
    {

        // verify the required parameter 'resources' is set
        if ($resources === null || (is_array($resources) && count($resources) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resources when calling toolsCreateMediaGet'
            );
        }



        $resourcePath = '/tools/create-media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resources,
            'resources', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsCreateMediaPost
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaPostRequest $toolsCreateMediaPostRequest toolsCreateMediaPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response
     */
    public function toolsCreateMediaPost($toolsCreateMediaPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaPost'][0])
    {
        list($response) = $this->toolsCreateMediaPostWithHttpInfo($toolsCreateMediaPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsCreateMediaPostWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaPostRequest $toolsCreateMediaPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsCreateMediaPostWithHttpInfo($toolsCreateMediaPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaPost'][0])
    {
        $request = $this->toolsCreateMediaPostRequest($toolsCreateMediaPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsCreateMediaPostAsync
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaPostRequest $toolsCreateMediaPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaPostAsync($toolsCreateMediaPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaPost'][0])
    {
        return $this->toolsCreateMediaPostAsyncWithHttpInfo($toolsCreateMediaPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsCreateMediaPostAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaPostRequest $toolsCreateMediaPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsCreateMediaPostAsyncWithHttpInfo($toolsCreateMediaPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\PatientsIdArchivePost200Response';
        $request = $this->toolsCreateMediaPostRequest($toolsCreateMediaPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsCreateMediaPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsCreateMediaPostRequest $toolsCreateMediaPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsCreateMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsCreateMediaPostRequest($toolsCreateMediaPostRequest = null, string $contentType = self::contentTypes['toolsCreateMediaPost'][0])
    {



        $resourcePath = '/tools/create-media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsCreateMediaPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsCreateMediaPostRequest));
            } else {
                $httpBody = $toolsCreateMediaPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsDefaultEncodingGet
     *
     * Get default encoding
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsDefaultEncodingGet(string $contentType = self::contentTypes['toolsDefaultEncodingGet'][0])
    {
        list($response) = $this->toolsDefaultEncodingGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsDefaultEncodingGetWithHttpInfo
     *
     * Get default encoding
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsDefaultEncodingGetWithHttpInfo(string $contentType = self::contentTypes['toolsDefaultEncodingGet'][0])
    {
        $request = $this->toolsDefaultEncodingGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsDefaultEncodingGetAsync
     *
     * Get default encoding
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDefaultEncodingGetAsync(string $contentType = self::contentTypes['toolsDefaultEncodingGet'][0])
    {
        return $this->toolsDefaultEncodingGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsDefaultEncodingGetAsyncWithHttpInfo
     *
     * Get default encoding
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDefaultEncodingGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsDefaultEncodingGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsDefaultEncodingGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsDefaultEncodingGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsDefaultEncodingGetRequest(string $contentType = self::contentTypes['toolsDefaultEncodingGet'][0])
    {


        $resourcePath = '/tools/default-encoding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsDefaultEncodingPut
     *
     * Set default encoding
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsDefaultEncodingPut($body = null, string $contentType = self::contentTypes['toolsDefaultEncodingPut'][0])
    {
        $this->toolsDefaultEncodingPutWithHttpInfo($body, $contentType);
    }

    /**
     * Operation toolsDefaultEncodingPutWithHttpInfo
     *
     * Set default encoding
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsDefaultEncodingPutWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsDefaultEncodingPut'][0])
    {
        $request = $this->toolsDefaultEncodingPutRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsDefaultEncodingPutAsync
     *
     * Set default encoding
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDefaultEncodingPutAsync($body = null, string $contentType = self::contentTypes['toolsDefaultEncodingPut'][0])
    {
        return $this->toolsDefaultEncodingPutAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsDefaultEncodingPutAsyncWithHttpInfo
     *
     * Set default encoding
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDefaultEncodingPutAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsDefaultEncodingPut'][0])
    {
        $returnType = '';
        $request = $this->toolsDefaultEncodingPutRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsDefaultEncodingPut'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDefaultEncodingPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsDefaultEncodingPutRequest($body = null, string $contentType = self::contentTypes['toolsDefaultEncodingPut'][0])
    {



        $resourcePath = '/tools/default-encoding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsDicomConformanceGet
     *
     * Get DICOM conformance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomConformanceGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsDicomConformanceGet(string $contentType = self::contentTypes['toolsDicomConformanceGet'][0])
    {
        list($response) = $this->toolsDicomConformanceGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsDicomConformanceGetWithHttpInfo
     *
     * Get DICOM conformance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomConformanceGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsDicomConformanceGetWithHttpInfo(string $contentType = self::contentTypes['toolsDicomConformanceGet'][0])
    {
        $request = $this->toolsDicomConformanceGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsDicomConformanceGetAsync
     *
     * Get DICOM conformance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomConformanceGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDicomConformanceGetAsync(string $contentType = self::contentTypes['toolsDicomConformanceGet'][0])
    {
        return $this->toolsDicomConformanceGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsDicomConformanceGetAsyncWithHttpInfo
     *
     * Get DICOM conformance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomConformanceGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDicomConformanceGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsDicomConformanceGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsDicomConformanceGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsDicomConformanceGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomConformanceGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsDicomConformanceGetRequest(string $contentType = self::contentTypes['toolsDicomConformanceGet'][0])
    {


        $resourcePath = '/tools/dicom-conformance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsDicomEchoPost
     *
     * Trigger C-ECHO SCU
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsDicomEchoPostRequest $toolsDicomEchoPostRequest toolsDicomEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomEchoPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsDicomEchoPost($toolsDicomEchoPostRequest = null, string $contentType = self::contentTypes['toolsDicomEchoPost'][0])
    {
        $this->toolsDicomEchoPostWithHttpInfo($toolsDicomEchoPostRequest, $contentType);
    }

    /**
     * Operation toolsDicomEchoPostWithHttpInfo
     *
     * Trigger C-ECHO SCU
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsDicomEchoPostRequest $toolsDicomEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomEchoPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsDicomEchoPostWithHttpInfo($toolsDicomEchoPostRequest = null, string $contentType = self::contentTypes['toolsDicomEchoPost'][0])
    {
        $request = $this->toolsDicomEchoPostRequest($toolsDicomEchoPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsDicomEchoPostAsync
     *
     * Trigger C-ECHO SCU
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsDicomEchoPostRequest $toolsDicomEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomEchoPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDicomEchoPostAsync($toolsDicomEchoPostRequest = null, string $contentType = self::contentTypes['toolsDicomEchoPost'][0])
    {
        return $this->toolsDicomEchoPostAsyncWithHttpInfo($toolsDicomEchoPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsDicomEchoPostAsyncWithHttpInfo
     *
     * Trigger C-ECHO SCU
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsDicomEchoPostRequest $toolsDicomEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomEchoPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsDicomEchoPostAsyncWithHttpInfo($toolsDicomEchoPostRequest = null, string $contentType = self::contentTypes['toolsDicomEchoPost'][0])
    {
        $returnType = '';
        $request = $this->toolsDicomEchoPostRequest($toolsDicomEchoPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsDicomEchoPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsDicomEchoPostRequest $toolsDicomEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsDicomEchoPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsDicomEchoPostRequest($toolsDicomEchoPostRequest = null, string $contentType = self::contentTypes['toolsDicomEchoPost'][0])
    {



        $resourcePath = '/tools/dicom-echo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsDicomEchoPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsDicomEchoPostRequest));
            } else {
                $httpBody = $toolsDicomEchoPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsExecuteScriptPost
     *
     * Execute Lua script
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsExecuteScriptPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsExecuteScriptPost($body = null, string $contentType = self::contentTypes['toolsExecuteScriptPost'][0])
    {
        list($response) = $this->toolsExecuteScriptPostWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation toolsExecuteScriptPostWithHttpInfo
     *
     * Execute Lua script
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsExecuteScriptPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsExecuteScriptPostWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsExecuteScriptPost'][0])
    {
        $request = $this->toolsExecuteScriptPostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsExecuteScriptPostAsync
     *
     * Execute Lua script
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsExecuteScriptPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsExecuteScriptPostAsync($body = null, string $contentType = self::contentTypes['toolsExecuteScriptPost'][0])
    {
        return $this->toolsExecuteScriptPostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsExecuteScriptPostAsyncWithHttpInfo
     *
     * Execute Lua script
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsExecuteScriptPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsExecuteScriptPostAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsExecuteScriptPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsExecuteScriptPostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsExecuteScriptPost'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsExecuteScriptPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsExecuteScriptPostRequest($body = null, string $contentType = self::contentTypes['toolsExecuteScriptPost'][0])
    {



        $resourcePath = '/tools/execute-script';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsFindPost
     *
     * Look for local resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsFindPostRequest $toolsFindPostRequest toolsFindPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsFindPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsFindPost($toolsFindPostRequest = null, string $contentType = self::contentTypes['toolsFindPost'][0])
    {
        list($response) = $this->toolsFindPostWithHttpInfo($toolsFindPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation toolsFindPostWithHttpInfo
     *
     * Look for local resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsFindPostRequest $toolsFindPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsFindPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsFindPostWithHttpInfo($toolsFindPostRequest = null, string $contentType = self::contentTypes['toolsFindPost'][0])
    {
        $request = $this->toolsFindPostRequest($toolsFindPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsFindPostAsync
     *
     * Look for local resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsFindPostRequest $toolsFindPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsFindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsFindPostAsync($toolsFindPostRequest = null, string $contentType = self::contentTypes['toolsFindPost'][0])
    {
        return $this->toolsFindPostAsyncWithHttpInfo($toolsFindPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsFindPostAsyncWithHttpInfo
     *
     * Look for local resources
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsFindPostRequest $toolsFindPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsFindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsFindPostAsyncWithHttpInfo($toolsFindPostRequest = null, string $contentType = self::contentTypes['toolsFindPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsFindPostRequest($toolsFindPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsFindPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsFindPostRequest $toolsFindPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsFindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsFindPostRequest($toolsFindPostRequest = null, string $contentType = self::contentTypes['toolsFindPost'][0])
    {



        $resourcePath = '/tools/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsFindPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsFindPostRequest));
            } else {
                $httpBody = $toolsFindPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsGenerateUidGet
     *
     * Generate an identifier
     *
     * @param  string $level Type of DICOM resource among: &#x60;patient&#x60;, &#x60;study&#x60;, &#x60;series&#x60; or &#x60;instance&#x60; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsGenerateUidGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsGenerateUidGet($level, string $contentType = self::contentTypes['toolsGenerateUidGet'][0])
    {
        list($response) = $this->toolsGenerateUidGetWithHttpInfo($level, $contentType);
        return $response;
    }

    /**
     * Operation toolsGenerateUidGetWithHttpInfo
     *
     * Generate an identifier
     *
     * @param  string $level Type of DICOM resource among: &#x60;patient&#x60;, &#x60;study&#x60;, &#x60;series&#x60; or &#x60;instance&#x60; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsGenerateUidGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsGenerateUidGetWithHttpInfo($level, string $contentType = self::contentTypes['toolsGenerateUidGet'][0])
    {
        $request = $this->toolsGenerateUidGetRequest($level, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsGenerateUidGetAsync
     *
     * Generate an identifier
     *
     * @param  string $level Type of DICOM resource among: &#x60;patient&#x60;, &#x60;study&#x60;, &#x60;series&#x60; or &#x60;instance&#x60; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsGenerateUidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsGenerateUidGetAsync($level, string $contentType = self::contentTypes['toolsGenerateUidGet'][0])
    {
        return $this->toolsGenerateUidGetAsyncWithHttpInfo($level, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsGenerateUidGetAsyncWithHttpInfo
     *
     * Generate an identifier
     *
     * @param  string $level Type of DICOM resource among: &#x60;patient&#x60;, &#x60;study&#x60;, &#x60;series&#x60; or &#x60;instance&#x60; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsGenerateUidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsGenerateUidGetAsyncWithHttpInfo($level, string $contentType = self::contentTypes['toolsGenerateUidGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsGenerateUidGetRequest($level, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsGenerateUidGet'
     *
     * @param  string $level Type of DICOM resource among: &#x60;patient&#x60;, &#x60;study&#x60;, &#x60;series&#x60; or &#x60;instance&#x60; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsGenerateUidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsGenerateUidGetRequest($level, string $contentType = self::contentTypes['toolsGenerateUidGet'][0])
    {

        // verify the required parameter 'level' is set
        if ($level === null || (is_array($level) && count($level) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $level when calling toolsGenerateUidGet'
            );
        }


        $resourcePath = '/tools/generate-uid';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsInvalidateTagsPost
     *
     * Invalidate DICOM-as-JSON summaries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsInvalidateTagsPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsInvalidateTagsPost(string $contentType = self::contentTypes['toolsInvalidateTagsPost'][0])
    {
        $this->toolsInvalidateTagsPostWithHttpInfo($contentType);
    }

    /**
     * Operation toolsInvalidateTagsPostWithHttpInfo
     *
     * Invalidate DICOM-as-JSON summaries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsInvalidateTagsPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsInvalidateTagsPostWithHttpInfo(string $contentType = self::contentTypes['toolsInvalidateTagsPost'][0])
    {
        $request = $this->toolsInvalidateTagsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsInvalidateTagsPostAsync
     *
     * Invalidate DICOM-as-JSON summaries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsInvalidateTagsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsInvalidateTagsPostAsync(string $contentType = self::contentTypes['toolsInvalidateTagsPost'][0])
    {
        return $this->toolsInvalidateTagsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsInvalidateTagsPostAsyncWithHttpInfo
     *
     * Invalidate DICOM-as-JSON summaries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsInvalidateTagsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsInvalidateTagsPostAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsInvalidateTagsPost'][0])
    {
        $returnType = '';
        $request = $this->toolsInvalidateTagsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsInvalidateTagsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsInvalidateTagsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsInvalidateTagsPostRequest(string $contentType = self::contentTypes['toolsInvalidateTagsPost'][0])
    {


        $resourcePath = '/tools/invalidate-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsLabelsGet
     *
     * Get all the used labels
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLabelsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsLabelsGet(string $contentType = self::contentTypes['toolsLabelsGet'][0])
    {
        list($response) = $this->toolsLabelsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsLabelsGetWithHttpInfo
     *
     * Get all the used labels
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLabelsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsLabelsGetWithHttpInfo(string $contentType = self::contentTypes['toolsLabelsGet'][0])
    {
        $request = $this->toolsLabelsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsLabelsGetAsync
     *
     * Get all the used labels
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLabelsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsLabelsGetAsync(string $contentType = self::contentTypes['toolsLabelsGet'][0])
    {
        return $this->toolsLabelsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsLabelsGetAsyncWithHttpInfo
     *
     * Get all the used labels
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLabelsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsLabelsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsLabelsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsLabelsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsLabelsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLabelsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsLabelsGetRequest(string $contentType = self::contentTypes['toolsLabelsGet'][0])
    {


        $resourcePath = '/tools/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsLookupPost
     *
     * Look for DICOM identifiers
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLookupPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsLookupPost($body = null, string $contentType = self::contentTypes['toolsLookupPost'][0])
    {
        list($response) = $this->toolsLookupPostWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation toolsLookupPostWithHttpInfo
     *
     * Look for DICOM identifiers
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLookupPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsLookupPostWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsLookupPost'][0])
    {
        $request = $this->toolsLookupPostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsLookupPostAsync
     *
     * Look for DICOM identifiers
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLookupPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsLookupPostAsync($body = null, string $contentType = self::contentTypes['toolsLookupPost'][0])
    {
        return $this->toolsLookupPostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsLookupPostAsyncWithHttpInfo
     *
     * Look for DICOM identifiers
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLookupPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsLookupPostAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsLookupPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsLookupPostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsLookupPost'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsLookupPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsLookupPostRequest($body = null, string $contentType = self::contentTypes['toolsLookupPost'][0])
    {



        $resourcePath = '/tools/lookup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsMetricsGet
     *
     * Are metrics collected?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsMetricsGet(string $contentType = self::contentTypes['toolsMetricsGet'][0])
    {
        list($response) = $this->toolsMetricsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsMetricsGetWithHttpInfo
     *
     * Are metrics collected?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsMetricsGetWithHttpInfo(string $contentType = self::contentTypes['toolsMetricsGet'][0])
    {
        $request = $this->toolsMetricsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsMetricsGetAsync
     *
     * Are metrics collected?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsMetricsGetAsync(string $contentType = self::contentTypes['toolsMetricsGet'][0])
    {
        return $this->toolsMetricsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsMetricsGetAsyncWithHttpInfo
     *
     * Are metrics collected?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsMetricsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsMetricsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsMetricsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsMetricsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsMetricsGetRequest(string $contentType = self::contentTypes['toolsMetricsGet'][0])
    {


        $resourcePath = '/tools/metrics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsMetricsPrometheusGet
     *
     * Get usage metrics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPrometheusGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsMetricsPrometheusGet(string $contentType = self::contentTypes['toolsMetricsPrometheusGet'][0])
    {
        $this->toolsMetricsPrometheusGetWithHttpInfo($contentType);
    }

    /**
     * Operation toolsMetricsPrometheusGetWithHttpInfo
     *
     * Get usage metrics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPrometheusGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsMetricsPrometheusGetWithHttpInfo(string $contentType = self::contentTypes['toolsMetricsPrometheusGet'][0])
    {
        $request = $this->toolsMetricsPrometheusGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsMetricsPrometheusGetAsync
     *
     * Get usage metrics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPrometheusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsMetricsPrometheusGetAsync(string $contentType = self::contentTypes['toolsMetricsPrometheusGet'][0])
    {
        return $this->toolsMetricsPrometheusGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsMetricsPrometheusGetAsyncWithHttpInfo
     *
     * Get usage metrics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPrometheusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsMetricsPrometheusGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsMetricsPrometheusGet'][0])
    {
        $returnType = '';
        $request = $this->toolsMetricsPrometheusGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsMetricsPrometheusGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPrometheusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsMetricsPrometheusGetRequest(string $contentType = self::contentTypes['toolsMetricsPrometheusGet'][0])
    {


        $resourcePath = '/tools/metrics-prometheus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsMetricsPut
     *
     * Enable collection of metrics
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsMetricsPut($body = null, string $contentType = self::contentTypes['toolsMetricsPut'][0])
    {
        $this->toolsMetricsPutWithHttpInfo($body, $contentType);
    }

    /**
     * Operation toolsMetricsPutWithHttpInfo
     *
     * Enable collection of metrics
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsMetricsPutWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsMetricsPut'][0])
    {
        $request = $this->toolsMetricsPutRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsMetricsPutAsync
     *
     * Enable collection of metrics
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsMetricsPutAsync($body = null, string $contentType = self::contentTypes['toolsMetricsPut'][0])
    {
        return $this->toolsMetricsPutAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsMetricsPutAsyncWithHttpInfo
     *
     * Enable collection of metrics
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsMetricsPutAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsMetricsPut'][0])
    {
        $returnType = '';
        $request = $this->toolsMetricsPutRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsMetricsPut'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsMetricsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsMetricsPutRequest($body = null, string $contentType = self::contentTypes['toolsMetricsPut'][0])
    {



        $resourcePath = '/tools/metrics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsNowGet
     *
     * Get UTC time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsNowGet(string $contentType = self::contentTypes['toolsNowGet'][0])
    {
        list($response) = $this->toolsNowGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsNowGetWithHttpInfo
     *
     * Get UTC time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsNowGetWithHttpInfo(string $contentType = self::contentTypes['toolsNowGet'][0])
    {
        $request = $this->toolsNowGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsNowGetAsync
     *
     * Get UTC time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsNowGetAsync(string $contentType = self::contentTypes['toolsNowGet'][0])
    {
        return $this->toolsNowGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsNowGetAsyncWithHttpInfo
     *
     * Get UTC time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsNowGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsNowGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsNowGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsNowGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsNowGetRequest(string $contentType = self::contentTypes['toolsNowGet'][0])
    {


        $resourcePath = '/tools/now';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsNowLocalGet
     *
     * Get local time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowLocalGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsNowLocalGet(string $contentType = self::contentTypes['toolsNowLocalGet'][0])
    {
        list($response) = $this->toolsNowLocalGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsNowLocalGetWithHttpInfo
     *
     * Get local time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowLocalGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsNowLocalGetWithHttpInfo(string $contentType = self::contentTypes['toolsNowLocalGet'][0])
    {
        $request = $this->toolsNowLocalGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsNowLocalGetAsync
     *
     * Get local time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowLocalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsNowLocalGetAsync(string $contentType = self::contentTypes['toolsNowLocalGet'][0])
    {
        return $this->toolsNowLocalGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsNowLocalGetAsyncWithHttpInfo
     *
     * Get local time
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowLocalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsNowLocalGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsNowLocalGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsNowLocalGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsNowLocalGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsNowLocalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsNowLocalGetRequest(string $contentType = self::contentTypes['toolsNowLocalGet'][0])
    {


        $resourcePath = '/tools/now-local';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsReconstructPost
     *
     * Reconstruct all the index
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsReconstructPostRequest $toolsReconstructPostRequest toolsReconstructPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsReconstructPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsReconstructPost($toolsReconstructPostRequest = null, string $contentType = self::contentTypes['toolsReconstructPost'][0])
    {
        $this->toolsReconstructPostWithHttpInfo($toolsReconstructPostRequest, $contentType);
    }

    /**
     * Operation toolsReconstructPostWithHttpInfo
     *
     * Reconstruct all the index
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsReconstructPostRequest $toolsReconstructPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsReconstructPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsReconstructPostWithHttpInfo($toolsReconstructPostRequest = null, string $contentType = self::contentTypes['toolsReconstructPost'][0])
    {
        $request = $this->toolsReconstructPostRequest($toolsReconstructPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsReconstructPostAsync
     *
     * Reconstruct all the index
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsReconstructPostRequest $toolsReconstructPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsReconstructPostAsync($toolsReconstructPostRequest = null, string $contentType = self::contentTypes['toolsReconstructPost'][0])
    {
        return $this->toolsReconstructPostAsyncWithHttpInfo($toolsReconstructPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsReconstructPostAsyncWithHttpInfo
     *
     * Reconstruct all the index
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsReconstructPostRequest $toolsReconstructPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsReconstructPostAsyncWithHttpInfo($toolsReconstructPostRequest = null, string $contentType = self::contentTypes['toolsReconstructPost'][0])
    {
        $returnType = '';
        $request = $this->toolsReconstructPostRequest($toolsReconstructPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsReconstructPost'
     *
     * @param  \Aurabx\OrthancPHP\Model\ToolsReconstructPostRequest $toolsReconstructPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsReconstructPostRequest($toolsReconstructPostRequest = null, string $contentType = self::contentTypes['toolsReconstructPost'][0])
    {



        $resourcePath = '/tools/reconstruct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($toolsReconstructPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toolsReconstructPostRequest));
            } else {
                $httpBody = $toolsReconstructPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsResetPost
     *
     * Restart Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsResetPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsResetPost(string $contentType = self::contentTypes['toolsResetPost'][0])
    {
        $this->toolsResetPostWithHttpInfo($contentType);
    }

    /**
     * Operation toolsResetPostWithHttpInfo
     *
     * Restart Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsResetPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsResetPostWithHttpInfo(string $contentType = self::contentTypes['toolsResetPost'][0])
    {
        $request = $this->toolsResetPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsResetPostAsync
     *
     * Restart Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsResetPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsResetPostAsync(string $contentType = self::contentTypes['toolsResetPost'][0])
    {
        return $this->toolsResetPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsResetPostAsyncWithHttpInfo
     *
     * Restart Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsResetPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsResetPostAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsResetPost'][0])
    {
        $returnType = '';
        $request = $this->toolsResetPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsResetPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsResetPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsResetPostRequest(string $contentType = self::contentTypes['toolsResetPost'][0])
    {


        $resourcePath = '/tools/reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsShutdownPost
     *
     * Shutdown Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsShutdownPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsShutdownPost(string $contentType = self::contentTypes['toolsShutdownPost'][0])
    {
        $this->toolsShutdownPostWithHttpInfo($contentType);
    }

    /**
     * Operation toolsShutdownPostWithHttpInfo
     *
     * Shutdown Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsShutdownPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsShutdownPostWithHttpInfo(string $contentType = self::contentTypes['toolsShutdownPost'][0])
    {
        $request = $this->toolsShutdownPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsShutdownPostAsync
     *
     * Shutdown Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsShutdownPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsShutdownPostAsync(string $contentType = self::contentTypes['toolsShutdownPost'][0])
    {
        return $this->toolsShutdownPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsShutdownPostAsyncWithHttpInfo
     *
     * Shutdown Orthanc
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsShutdownPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsShutdownPostAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsShutdownPost'][0])
    {
        $returnType = '';
        $request = $this->toolsShutdownPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsShutdownPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsShutdownPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsShutdownPostRequest(string $contentType = self::contentTypes['toolsShutdownPost'][0])
    {


        $resourcePath = '/tools/shutdown';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsUnknownSopClassAcceptedGet
     *
     * Is unknown SOP class accepted?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function toolsUnknownSopClassAcceptedGet(string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedGet'][0])
    {
        list($response) = $this->toolsUnknownSopClassAcceptedGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation toolsUnknownSopClassAcceptedGetWithHttpInfo
     *
     * Is unknown SOP class accepted?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsUnknownSopClassAcceptedGetWithHttpInfo(string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedGet'][0])
    {
        $request = $this->toolsUnknownSopClassAcceptedGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation toolsUnknownSopClassAcceptedGetAsync
     *
     * Is unknown SOP class accepted?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsUnknownSopClassAcceptedGetAsync(string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedGet'][0])
    {
        return $this->toolsUnknownSopClassAcceptedGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsUnknownSopClassAcceptedGetAsyncWithHttpInfo
     *
     * Is unknown SOP class accepted?
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsUnknownSopClassAcceptedGetAsyncWithHttpInfo(string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->toolsUnknownSopClassAcceptedGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsUnknownSopClassAcceptedGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsUnknownSopClassAcceptedGetRequest(string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedGet'][0])
    {


        $resourcePath = '/tools/unknown-sop-class-accepted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toolsUnknownSopClassAcceptedPut
     *
     * Set unknown SOP class accepted
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function toolsUnknownSopClassAcceptedPut($body = null, string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedPut'][0])
    {
        $this->toolsUnknownSopClassAcceptedPutWithHttpInfo($body, $contentType);
    }

    /**
     * Operation toolsUnknownSopClassAcceptedPutWithHttpInfo
     *
     * Set unknown SOP class accepted
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function toolsUnknownSopClassAcceptedPutWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedPut'][0])
    {
        $request = $this->toolsUnknownSopClassAcceptedPutRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation toolsUnknownSopClassAcceptedPutAsync
     *
     * Set unknown SOP class accepted
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsUnknownSopClassAcceptedPutAsync($body = null, string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedPut'][0])
    {
        return $this->toolsUnknownSopClassAcceptedPutAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toolsUnknownSopClassAcceptedPutAsyncWithHttpInfo
     *
     * Set unknown SOP class accepted
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toolsUnknownSopClassAcceptedPutAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedPut'][0])
    {
        $returnType = '';
        $request = $this->toolsUnknownSopClassAcceptedPutRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toolsUnknownSopClassAcceptedPut'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toolsUnknownSopClassAcceptedPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toolsUnknownSopClassAcceptedPutRequest($body = null, string $contentType = self::contentTypes['toolsUnknownSopClassAcceptedPut'][0])
    {



        $resourcePath = '/tools/unknown-sop-class-accepted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
