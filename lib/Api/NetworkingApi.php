<?php
/**
 * NetworkingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Aurabx\OrthancPHP
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://orthanc.uclouvain.be/book/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://orthanc.uclouvain.be/book/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.12.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Aurabx\OrthancPHP\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aurabx\OrthancPHP\ApiException;
use Aurabx\OrthancPHP\Configuration;
use Aurabx\OrthancPHP\HeaderSelector;
use Aurabx\OrthancPHP\ObjectSerializer;

/**
 * NetworkingApi Class Doc Comment
 *
 * @category Class
 * @package  Aurabx\OrthancPHP
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NetworkingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'modalitiesGet' => [
            'application/json',
        ],
        'modalitiesIdConfigurationGet' => [
            'application/json',
        ],
        'modalitiesIdDelete' => [
            'application/json',
        ],
        'modalitiesIdEchoPost' => [
            'application/json',
        ],
        'modalitiesIdFindInstancePost' => [
            'application/json',
        ],
        'modalitiesIdFindPatientPost' => [
            'application/json',
        ],
        'modalitiesIdFindPost' => [
            'application/json',
        ],
        'modalitiesIdFindSeriesPost' => [
            'application/json',
        ],
        'modalitiesIdFindStudyPost' => [
            'application/json',
        ],
        'modalitiesIdFindWorklistPost' => [
            'application/json',
        ],
        'modalitiesIdGet' => [
            'application/json',
        ],
        'modalitiesIdMovePost' => [
            'application/json',
        ],
        'modalitiesIdPut' => [
            'application/json',
        ],
        'modalitiesIdQueryPost' => [
            'application/json',
        ],
        'modalitiesIdStorageCommitmentPost' => [
            'application/json',
        ],
        'modalitiesIdStorePost' => [
            'application/json',
            'text/plain',
        ],
        'modalitiesIdStoreStraightPost' => [
            'application/dicom',
        ],
        'peersGet' => [
            'application/json',
        ],
        'peersIdConfigurationGet' => [
            'application/json',
        ],
        'peersIdDelete' => [
            'application/json',
        ],
        'peersIdGet' => [
            'application/json',
        ],
        'peersIdPut' => [
            'application/json',
        ],
        'peersIdStorePost' => [
            'application/json',
            'text/plain',
        ],
        'peersIdStoreStraightPost' => [
            'application/dicom',
        ],
        'peersIdSystemGet' => [
            'application/json',
        ],
        'queriesGet' => [
            'application/json',
        ],
        'queriesIdAnswersGet' => [
            'application/json',
        ],
        'queriesIdAnswersIndexContentGet' => [
            'application/json',
        ],
        'queriesIdAnswersIndexGet' => [
            'application/json',
        ],
        'queriesIdAnswersIndexQueryInstancesPost' => [
            'application/json',
        ],
        'queriesIdAnswersIndexQuerySeriesPost' => [
            'application/json',
        ],
        'queriesIdAnswersIndexQueryStudiesPost' => [
            'application/json',
        ],
        'queriesIdAnswersIndexRetrievePost' => [
            'application/json',
            'text/plain',
        ],
        'queriesIdDelete' => [
            'application/json',
        ],
        'queriesIdGet' => [
            'application/json',
        ],
        'queriesIdLevelGet' => [
            'application/json',
        ],
        'queriesIdModalityGet' => [
            'application/json',
        ],
        'queriesIdQueryGet' => [
            'application/json',
        ],
        'queriesIdRetrievePost' => [
            'application/json',
            'text/plain',
        ],
        'storageCommitmentIdGet' => [
            'application/json',
        ],
        'storageCommitmentIdRemovePost' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation modalitiesGet
     *
     * List DICOM modalities
     *
     * @param  string $expand If present, retrieve detailed information about the individual DICOM modalities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function modalitiesGet($expand = null, string $contentType = self::contentTypes['modalitiesGet'][0])
    {
        list($response) = $this->modalitiesGetWithHttpInfo($expand, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesGetWithHttpInfo
     *
     * List DICOM modalities
     *
     * @param  string $expand If present, retrieve detailed information about the individual DICOM modalities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesGetWithHttpInfo($expand = null, string $contentType = self::contentTypes['modalitiesGet'][0])
    {
        $request = $this->modalitiesGetRequest($expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesGetAsync
     *
     * List DICOM modalities
     *
     * @param  string $expand If present, retrieve detailed information about the individual DICOM modalities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesGetAsync($expand = null, string $contentType = self::contentTypes['modalitiesGet'][0])
    {
        return $this->modalitiesGetAsyncWithHttpInfo($expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesGetAsyncWithHttpInfo
     *
     * List DICOM modalities
     *
     * @param  string $expand If present, retrieve detailed information about the individual DICOM modalities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesGetAsyncWithHttpInfo($expand = null, string $contentType = self::contentTypes['modalitiesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesGetRequest($expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesGet'
     *
     * @param  string $expand If present, retrieve detailed information about the individual DICOM modalities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesGetRequest($expand = null, string $contentType = self::contentTypes['modalitiesGet'][0])
    {



        $resourcePath = '/modalities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdConfigurationGet
     *
     * Get modality configuration
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function modalitiesIdConfigurationGet($id, string $contentType = self::contentTypes['modalitiesIdConfigurationGet'][0])
    {
        list($response) = $this->modalitiesIdConfigurationGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdConfigurationGetWithHttpInfo
     *
     * Get modality configuration
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdConfigurationGetWithHttpInfo($id, string $contentType = self::contentTypes['modalitiesIdConfigurationGet'][0])
    {
        $request = $this->modalitiesIdConfigurationGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdConfigurationGetAsync
     *
     * Get modality configuration
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdConfigurationGetAsync($id, string $contentType = self::contentTypes['modalitiesIdConfigurationGet'][0])
    {
        return $this->modalitiesIdConfigurationGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdConfigurationGetAsyncWithHttpInfo
     *
     * Get modality configuration
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdConfigurationGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['modalitiesIdConfigurationGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdConfigurationGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdConfigurationGet'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdConfigurationGetRequest($id, string $contentType = self::contentTypes['modalitiesIdConfigurationGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdConfigurationGet'
            );
        }


        $resourcePath = '/modalities/{id}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdDelete
     *
     * Delete DICOM modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdDelete'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modalitiesIdDelete($id, string $contentType = self::contentTypes['modalitiesIdDelete'][0])
    {
        $this->modalitiesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation modalitiesIdDeleteWithHttpInfo
     *
     * Delete DICOM modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdDelete'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['modalitiesIdDelete'][0])
    {
        $request = $this->modalitiesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdDeleteAsync
     *
     * Delete DICOM modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdDeleteAsync($id, string $contentType = self::contentTypes['modalitiesIdDelete'][0])
    {
        return $this->modalitiesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdDeleteAsyncWithHttpInfo
     *
     * Delete DICOM modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['modalitiesIdDelete'][0])
    {
        $returnType = '';
        $request = $this->modalitiesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdDelete'
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdDeleteRequest($id, string $contentType = self::contentTypes['modalitiesIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdDelete'
            );
        }


        $resourcePath = '/modalities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdEchoPost
     *
     * Trigger C-ECHO SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdEchoPostRequest $modalitiesIdEchoPostRequest modalitiesIdEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdEchoPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modalitiesIdEchoPost($id, $modalitiesIdEchoPostRequest = null, string $contentType = self::contentTypes['modalitiesIdEchoPost'][0])
    {
        $this->modalitiesIdEchoPostWithHttpInfo($id, $modalitiesIdEchoPostRequest, $contentType);
    }

    /**
     * Operation modalitiesIdEchoPostWithHttpInfo
     *
     * Trigger C-ECHO SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdEchoPostRequest $modalitiesIdEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdEchoPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdEchoPostWithHttpInfo($id, $modalitiesIdEchoPostRequest = null, string $contentType = self::contentTypes['modalitiesIdEchoPost'][0])
    {
        $request = $this->modalitiesIdEchoPostRequest($id, $modalitiesIdEchoPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdEchoPostAsync
     *
     * Trigger C-ECHO SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdEchoPostRequest $modalitiesIdEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdEchoPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdEchoPostAsync($id, $modalitiesIdEchoPostRequest = null, string $contentType = self::contentTypes['modalitiesIdEchoPost'][0])
    {
        return $this->modalitiesIdEchoPostAsyncWithHttpInfo($id, $modalitiesIdEchoPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdEchoPostAsyncWithHttpInfo
     *
     * Trigger C-ECHO SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdEchoPostRequest $modalitiesIdEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdEchoPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdEchoPostAsyncWithHttpInfo($id, $modalitiesIdEchoPostRequest = null, string $contentType = self::contentTypes['modalitiesIdEchoPost'][0])
    {
        $returnType = '';
        $request = $this->modalitiesIdEchoPostRequest($id, $modalitiesIdEchoPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdEchoPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdEchoPostRequest $modalitiesIdEchoPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdEchoPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdEchoPostRequest($id, $modalitiesIdEchoPostRequest = null, string $contentType = self::contentTypes['modalitiesIdEchoPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdEchoPost'
            );
        }



        $resourcePath = '/modalities/{id}/echo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdEchoPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdEchoPostRequest));
            } else {
                $httpBody = $modalitiesIdEchoPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdFindInstancePost
     *
     * C-FIND SCU for instances
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindInstancePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     * @deprecated
     */
    public function modalitiesIdFindInstancePost($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindInstancePost'][0])
    {
        list($response) = $this->modalitiesIdFindInstancePostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdFindInstancePostWithHttpInfo
     *
     * C-FIND SCU for instances
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindInstancePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function modalitiesIdFindInstancePostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindInstancePost'][0])
    {
        $request = $this->modalitiesIdFindInstancePostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdFindInstancePostAsync
     *
     * C-FIND SCU for instances
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindInstancePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindInstancePostAsync($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindInstancePost'][0])
    {
        return $this->modalitiesIdFindInstancePostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdFindInstancePostAsyncWithHttpInfo
     *
     * C-FIND SCU for instances
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindInstancePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindInstancePostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindInstancePost'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdFindInstancePostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdFindInstancePost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindInstancePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function modalitiesIdFindInstancePostRequest($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindInstancePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdFindInstancePost'
            );
        }



        $resourcePath = '/modalities/{id}/find-instance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdFindPatientPost
     *
     * C-FIND SCU for patients
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPatientPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     * @deprecated
     */
    public function modalitiesIdFindPatientPost($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPatientPost'][0])
    {
        list($response) = $this->modalitiesIdFindPatientPostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdFindPatientPostWithHttpInfo
     *
     * C-FIND SCU for patients
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPatientPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function modalitiesIdFindPatientPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPatientPost'][0])
    {
        $request = $this->modalitiesIdFindPatientPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdFindPatientPostAsync
     *
     * C-FIND SCU for patients
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPatientPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindPatientPostAsync($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPatientPost'][0])
    {
        return $this->modalitiesIdFindPatientPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdFindPatientPostAsyncWithHttpInfo
     *
     * C-FIND SCU for patients
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPatientPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindPatientPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPatientPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdFindPatientPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdFindPatientPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPatientPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function modalitiesIdFindPatientPostRequest($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPatientPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdFindPatientPost'
            );
        }



        $resourcePath = '/modalities/{id}/find-patient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdFindPost
     *
     * Hierarchical C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     * @deprecated
     */
    public function modalitiesIdFindPost($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPost'][0])
    {
        list($response) = $this->modalitiesIdFindPostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdFindPostWithHttpInfo
     *
     * Hierarchical C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function modalitiesIdFindPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPost'][0])
    {
        $request = $this->modalitiesIdFindPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdFindPostAsync
     *
     * Hierarchical C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindPostAsync($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPost'][0])
    {
        return $this->modalitiesIdFindPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdFindPostAsyncWithHttpInfo
     *
     * Hierarchical C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdFindPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdFindPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function modalitiesIdFindPostRequest($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdFindPost'
            );
        }



        $resourcePath = '/modalities/{id}/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdFindSeriesPost
     *
     * C-FIND SCU for series
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindSeriesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     * @deprecated
     */
    public function modalitiesIdFindSeriesPost($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindSeriesPost'][0])
    {
        list($response) = $this->modalitiesIdFindSeriesPostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdFindSeriesPostWithHttpInfo
     *
     * C-FIND SCU for series
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindSeriesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function modalitiesIdFindSeriesPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindSeriesPost'][0])
    {
        $request = $this->modalitiesIdFindSeriesPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdFindSeriesPostAsync
     *
     * C-FIND SCU for series
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindSeriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindSeriesPostAsync($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindSeriesPost'][0])
    {
        return $this->modalitiesIdFindSeriesPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdFindSeriesPostAsyncWithHttpInfo
     *
     * C-FIND SCU for series
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindSeriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindSeriesPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindSeriesPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdFindSeriesPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdFindSeriesPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindSeriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function modalitiesIdFindSeriesPostRequest($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindSeriesPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdFindSeriesPost'
            );
        }



        $resourcePath = '/modalities/{id}/find-series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdFindStudyPost
     *
     * C-FIND SCU for studies
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindStudyPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     * @deprecated
     */
    public function modalitiesIdFindStudyPost($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindStudyPost'][0])
    {
        list($response) = $this->modalitiesIdFindStudyPostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdFindStudyPostWithHttpInfo
     *
     * C-FIND SCU for studies
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindStudyPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function modalitiesIdFindStudyPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindStudyPost'][0])
    {
        $request = $this->modalitiesIdFindStudyPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdFindStudyPostAsync
     *
     * C-FIND SCU for studies
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindStudyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindStudyPostAsync($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindStudyPost'][0])
    {
        return $this->modalitiesIdFindStudyPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdFindStudyPostAsyncWithHttpInfo
     *
     * C-FIND SCU for studies
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindStudyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function modalitiesIdFindStudyPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindStudyPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdFindStudyPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdFindStudyPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindStudyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function modalitiesIdFindStudyPostRequest($id, $body = null, string $contentType = self::contentTypes['modalitiesIdFindStudyPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdFindStudyPost'
            );
        }



        $resourcePath = '/modalities/{id}/find-study';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdFindWorklistPost
     *
     * C-FIND SCU for worklist
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdFindWorklistPostRequest $modalitiesIdFindWorklistPostRequest modalitiesIdFindWorklistPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindWorklistPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function modalitiesIdFindWorklistPost($id, $modalitiesIdFindWorklistPostRequest = null, string $contentType = self::contentTypes['modalitiesIdFindWorklistPost'][0])
    {
        list($response) = $this->modalitiesIdFindWorklistPostWithHttpInfo($id, $modalitiesIdFindWorklistPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdFindWorklistPostWithHttpInfo
     *
     * C-FIND SCU for worklist
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdFindWorklistPostRequest $modalitiesIdFindWorklistPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindWorklistPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdFindWorklistPostWithHttpInfo($id, $modalitiesIdFindWorklistPostRequest = null, string $contentType = self::contentTypes['modalitiesIdFindWorklistPost'][0])
    {
        $request = $this->modalitiesIdFindWorklistPostRequest($id, $modalitiesIdFindWorklistPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdFindWorklistPostAsync
     *
     * C-FIND SCU for worklist
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdFindWorklistPostRequest $modalitiesIdFindWorklistPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindWorklistPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdFindWorklistPostAsync($id, $modalitiesIdFindWorklistPostRequest = null, string $contentType = self::contentTypes['modalitiesIdFindWorklistPost'][0])
    {
        return $this->modalitiesIdFindWorklistPostAsyncWithHttpInfo($id, $modalitiesIdFindWorklistPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdFindWorklistPostAsyncWithHttpInfo
     *
     * C-FIND SCU for worklist
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdFindWorklistPostRequest $modalitiesIdFindWorklistPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindWorklistPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdFindWorklistPostAsyncWithHttpInfo($id, $modalitiesIdFindWorklistPostRequest = null, string $contentType = self::contentTypes['modalitiesIdFindWorklistPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdFindWorklistPostRequest($id, $modalitiesIdFindWorklistPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdFindWorklistPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdFindWorklistPostRequest $modalitiesIdFindWorklistPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdFindWorklistPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdFindWorklistPostRequest($id, $modalitiesIdFindWorklistPostRequest = null, string $contentType = self::contentTypes['modalitiesIdFindWorklistPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdFindWorklistPost'
            );
        }



        $resourcePath = '/modalities/{id}/find-worklist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdFindWorklistPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdFindWorklistPostRequest));
            } else {
                $httpBody = $modalitiesIdFindWorklistPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdGet
     *
     * List operations on modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function modalitiesIdGet($id, string $contentType = self::contentTypes['modalitiesIdGet'][0])
    {
        list($response) = $this->modalitiesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdGetWithHttpInfo
     *
     * List operations on modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdGetWithHttpInfo($id, string $contentType = self::contentTypes['modalitiesIdGet'][0])
    {
        $request = $this->modalitiesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdGetAsync
     *
     * List operations on modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdGetAsync($id, string $contentType = self::contentTypes['modalitiesIdGet'][0])
    {
        return $this->modalitiesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdGetAsyncWithHttpInfo
     *
     * List operations on modality
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['modalitiesIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->modalitiesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdGet'
     *
     * @param  string $id Identifier of the DICOM modality of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdGetRequest($id, string $contentType = self::contentTypes['modalitiesIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdGet'
            );
        }


        $resourcePath = '/modalities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdMovePost
     *
     * Trigger C-MOVE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdMovePostRequest $modalitiesIdMovePostRequest modalitiesIdMovePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdMovePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response
     */
    public function modalitiesIdMovePost($id, $modalitiesIdMovePostRequest = null, string $contentType = self::contentTypes['modalitiesIdMovePost'][0])
    {
        list($response) = $this->modalitiesIdMovePostWithHttpInfo($id, $modalitiesIdMovePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdMovePostWithHttpInfo
     *
     * Trigger C-MOVE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdMovePostRequest $modalitiesIdMovePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdMovePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdMovePostWithHttpInfo($id, $modalitiesIdMovePostRequest = null, string $contentType = self::contentTypes['modalitiesIdMovePost'][0])
    {
        $request = $this->modalitiesIdMovePostRequest($id, $modalitiesIdMovePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdMovePostAsync
     *
     * Trigger C-MOVE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdMovePostRequest $modalitiesIdMovePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdMovePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdMovePostAsync($id, $modalitiesIdMovePostRequest = null, string $contentType = self::contentTypes['modalitiesIdMovePost'][0])
    {
        return $this->modalitiesIdMovePostAsyncWithHttpInfo($id, $modalitiesIdMovePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdMovePostAsyncWithHttpInfo
     *
     * Trigger C-MOVE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdMovePostRequest $modalitiesIdMovePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdMovePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdMovePostAsyncWithHttpInfo($id, $modalitiesIdMovePostRequest = null, string $contentType = self::contentTypes['modalitiesIdMovePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
        $request = $this->modalitiesIdMovePostRequest($id, $modalitiesIdMovePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdMovePost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdMovePostRequest $modalitiesIdMovePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdMovePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdMovePostRequest($id, $modalitiesIdMovePostRequest = null, string $contentType = self::contentTypes['modalitiesIdMovePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdMovePost'
            );
        }



        $resourcePath = '/modalities/{id}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdMovePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdMovePostRequest));
            } else {
                $httpBody = $modalitiesIdMovePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdPut
     *
     * Update DICOM modality
     *
     * @param  string $id Identifier of the new/updated DICOM modality (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdPutRequest $modalitiesIdPutRequest modalitiesIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modalitiesIdPut($id, $modalitiesIdPutRequest = null, string $contentType = self::contentTypes['modalitiesIdPut'][0])
    {
        $this->modalitiesIdPutWithHttpInfo($id, $modalitiesIdPutRequest, $contentType);
    }

    /**
     * Operation modalitiesIdPutWithHttpInfo
     *
     * Update DICOM modality
     *
     * @param  string $id Identifier of the new/updated DICOM modality (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdPutRequest $modalitiesIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdPutWithHttpInfo($id, $modalitiesIdPutRequest = null, string $contentType = self::contentTypes['modalitiesIdPut'][0])
    {
        $request = $this->modalitiesIdPutRequest($id, $modalitiesIdPutRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdPutAsync
     *
     * Update DICOM modality
     *
     * @param  string $id Identifier of the new/updated DICOM modality (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdPutRequest $modalitiesIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdPutAsync($id, $modalitiesIdPutRequest = null, string $contentType = self::contentTypes['modalitiesIdPut'][0])
    {
        return $this->modalitiesIdPutAsyncWithHttpInfo($id, $modalitiesIdPutRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdPutAsyncWithHttpInfo
     *
     * Update DICOM modality
     *
     * @param  string $id Identifier of the new/updated DICOM modality (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdPutRequest $modalitiesIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdPutAsyncWithHttpInfo($id, $modalitiesIdPutRequest = null, string $contentType = self::contentTypes['modalitiesIdPut'][0])
    {
        $returnType = '';
        $request = $this->modalitiesIdPutRequest($id, $modalitiesIdPutRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdPut'
     *
     * @param  string $id Identifier of the new/updated DICOM modality (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdPutRequest $modalitiesIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdPutRequest($id, $modalitiesIdPutRequest = null, string $contentType = self::contentTypes['modalitiesIdPut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdPut'
            );
        }



        $resourcePath = '/modalities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdPutRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdPutRequest));
            } else {
                $httpBody = $modalitiesIdPutRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdQueryPost
     *
     * Trigger C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPostRequest $modalitiesIdQueryPostRequest modalitiesIdQueryPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdQueryPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response
     */
    public function modalitiesIdQueryPost($id, $modalitiesIdQueryPostRequest = null, string $contentType = self::contentTypes['modalitiesIdQueryPost'][0])
    {
        list($response) = $this->modalitiesIdQueryPostWithHttpInfo($id, $modalitiesIdQueryPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdQueryPostWithHttpInfo
     *
     * Trigger C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPostRequest $modalitiesIdQueryPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdQueryPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdQueryPostWithHttpInfo($id, $modalitiesIdQueryPostRequest = null, string $contentType = self::contentTypes['modalitiesIdQueryPost'][0])
    {
        $request = $this->modalitiesIdQueryPostRequest($id, $modalitiesIdQueryPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdQueryPostAsync
     *
     * Trigger C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPostRequest $modalitiesIdQueryPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdQueryPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdQueryPostAsync($id, $modalitiesIdQueryPostRequest = null, string $contentType = self::contentTypes['modalitiesIdQueryPost'][0])
    {
        return $this->modalitiesIdQueryPostAsyncWithHttpInfo($id, $modalitiesIdQueryPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdQueryPostAsyncWithHttpInfo
     *
     * Trigger C-FIND SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPostRequest $modalitiesIdQueryPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdQueryPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdQueryPostAsyncWithHttpInfo($id, $modalitiesIdQueryPostRequest = null, string $contentType = self::contentTypes['modalitiesIdQueryPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
        $request = $this->modalitiesIdQueryPostRequest($id, $modalitiesIdQueryPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdQueryPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPostRequest $modalitiesIdQueryPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdQueryPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdQueryPostRequest($id, $modalitiesIdQueryPostRequest = null, string $contentType = self::contentTypes['modalitiesIdQueryPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdQueryPost'
            );
        }



        $resourcePath = '/modalities/{id}/query';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdQueryPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdQueryPostRequest));
            } else {
                $httpBody = $modalitiesIdQueryPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdStorageCommitmentPost
     *
     * Trigger storage commitment request
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPostRequest $modalitiesIdStorageCommitmentPostRequest modalitiesIdStorageCommitmentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorageCommitmentPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response
     */
    public function modalitiesIdStorageCommitmentPost($id, $modalitiesIdStorageCommitmentPostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorageCommitmentPost'][0])
    {
        list($response) = $this->modalitiesIdStorageCommitmentPostWithHttpInfo($id, $modalitiesIdStorageCommitmentPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdStorageCommitmentPostWithHttpInfo
     *
     * Trigger storage commitment request
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPostRequest $modalitiesIdStorageCommitmentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorageCommitmentPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdStorageCommitmentPostWithHttpInfo($id, $modalitiesIdStorageCommitmentPostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorageCommitmentPost'][0])
    {
        $request = $this->modalitiesIdStorageCommitmentPostRequest($id, $modalitiesIdStorageCommitmentPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdStorageCommitmentPostAsync
     *
     * Trigger storage commitment request
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPostRequest $modalitiesIdStorageCommitmentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorageCommitmentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdStorageCommitmentPostAsync($id, $modalitiesIdStorageCommitmentPostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorageCommitmentPost'][0])
    {
        return $this->modalitiesIdStorageCommitmentPostAsyncWithHttpInfo($id, $modalitiesIdStorageCommitmentPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdStorageCommitmentPostAsyncWithHttpInfo
     *
     * Trigger storage commitment request
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPostRequest $modalitiesIdStorageCommitmentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorageCommitmentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdStorageCommitmentPostAsyncWithHttpInfo($id, $modalitiesIdStorageCommitmentPostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorageCommitmentPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPost200Response';
        $request = $this->modalitiesIdStorageCommitmentPostRequest($id, $modalitiesIdStorageCommitmentPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdStorageCommitmentPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorageCommitmentPostRequest $modalitiesIdStorageCommitmentPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorageCommitmentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdStorageCommitmentPostRequest($id, $modalitiesIdStorageCommitmentPostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorageCommitmentPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdStorageCommitmentPost'
            );
        }



        $resourcePath = '/modalities/{id}/storage-commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdStorageCommitmentPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdStorageCommitmentPostRequest));
            } else {
                $httpBody = $modalitiesIdStorageCommitmentPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdStorePost
     *
     * Trigger C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorePostRequest $modalitiesIdStorePostRequest modalitiesIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response
     */
    public function modalitiesIdStorePost($id, $modalitiesIdStorePostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorePost'][0])
    {
        list($response) = $this->modalitiesIdStorePostWithHttpInfo($id, $modalitiesIdStorePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdStorePostWithHttpInfo
     *
     * Trigger C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorePostRequest $modalitiesIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdStorePostWithHttpInfo($id, $modalitiesIdStorePostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorePost'][0])
    {
        $request = $this->modalitiesIdStorePostRequest($id, $modalitiesIdStorePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdStorePostAsync
     *
     * Trigger C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorePostRequest $modalitiesIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdStorePostAsync($id, $modalitiesIdStorePostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorePost'][0])
    {
        return $this->modalitiesIdStorePostAsyncWithHttpInfo($id, $modalitiesIdStorePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdStorePostAsyncWithHttpInfo
     *
     * Trigger C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorePostRequest $modalitiesIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdStorePostAsyncWithHttpInfo($id, $modalitiesIdStorePostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
        $request = $this->modalitiesIdStorePostRequest($id, $modalitiesIdStorePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdStorePost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\ModalitiesIdStorePostRequest $modalitiesIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdStorePostRequest($id, $modalitiesIdStorePostRequest = null, string $contentType = self::contentTypes['modalitiesIdStorePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdStorePost'
            );
        }



        $resourcePath = '/modalities/{id}/store';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modalitiesIdStorePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modalitiesIdStorePostRequest));
            } else {
                $httpBody = $modalitiesIdStorePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modalitiesIdStoreStraightPost
     *
     * Straight C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response
     */
    public function modalitiesIdStoreStraightPost($id, $body = null, string $contentType = self::contentTypes['modalitiesIdStoreStraightPost'][0])
    {
        list($response) = $this->modalitiesIdStoreStraightPostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation modalitiesIdStoreStraightPostWithHttpInfo
     *
     * Straight C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function modalitiesIdStoreStraightPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdStoreStraightPost'][0])
    {
        $request = $this->modalitiesIdStoreStraightPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modalitiesIdStoreStraightPostAsync
     *
     * Straight C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdStoreStraightPostAsync($id, $body = null, string $contentType = self::contentTypes['modalitiesIdStoreStraightPost'][0])
    {
        return $this->modalitiesIdStoreStraightPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modalitiesIdStoreStraightPostAsyncWithHttpInfo
     *
     * Straight C-STORE SCU
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modalitiesIdStoreStraightPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['modalitiesIdStoreStraightPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdStoreStraightPost200Response';
        $request = $this->modalitiesIdStoreStraightPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modalitiesIdStoreStraightPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modalitiesIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modalitiesIdStoreStraightPostRequest($id, $body = null, string $contentType = self::contentTypes['modalitiesIdStoreStraightPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modalitiesIdStoreStraightPost'
            );
        }



        $resourcePath = '/modalities/{id}/store-straight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersGet
     *
     * List Orthanc peers
     *
     * @param  string $expand If present, retrieve detailed information about the individual Orthanc peers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function peersGet($expand = null, string $contentType = self::contentTypes['peersGet'][0])
    {
        list($response) = $this->peersGetWithHttpInfo($expand, $contentType);
        return $response;
    }

    /**
     * Operation peersGetWithHttpInfo
     *
     * List Orthanc peers
     *
     * @param  string $expand If present, retrieve detailed information about the individual Orthanc peers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersGetWithHttpInfo($expand = null, string $contentType = self::contentTypes['peersGet'][0])
    {
        $request = $this->peersGetRequest($expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation peersGetAsync
     *
     * List Orthanc peers
     *
     * @param  string $expand If present, retrieve detailed information about the individual Orthanc peers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersGetAsync($expand = null, string $contentType = self::contentTypes['peersGet'][0])
    {
        return $this->peersGetAsyncWithHttpInfo($expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersGetAsyncWithHttpInfo
     *
     * List Orthanc peers
     *
     * @param  string $expand If present, retrieve detailed information about the individual Orthanc peers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersGetAsyncWithHttpInfo($expand = null, string $contentType = self::contentTypes['peersGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->peersGetRequest($expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersGet'
     *
     * @param  string $expand If present, retrieve detailed information about the individual Orthanc peers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersGetRequest($expand = null, string $contentType = self::contentTypes['peersGet'][0])
    {



        $resourcePath = '/peers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdConfigurationGet
     *
     * Get peer configuration
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function peersIdConfigurationGet($id, string $contentType = self::contentTypes['peersIdConfigurationGet'][0])
    {
        list($response) = $this->peersIdConfigurationGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation peersIdConfigurationGetWithHttpInfo
     *
     * Get peer configuration
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdConfigurationGetWithHttpInfo($id, string $contentType = self::contentTypes['peersIdConfigurationGet'][0])
    {
        $request = $this->peersIdConfigurationGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdConfigurationGetAsync
     *
     * Get peer configuration
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdConfigurationGetAsync($id, string $contentType = self::contentTypes['peersIdConfigurationGet'][0])
    {
        return $this->peersIdConfigurationGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdConfigurationGetAsyncWithHttpInfo
     *
     * Get peer configuration
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdConfigurationGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['peersIdConfigurationGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->peersIdConfigurationGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdConfigurationGet'
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdConfigurationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdConfigurationGetRequest($id, string $contentType = self::contentTypes['peersIdConfigurationGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdConfigurationGet'
            );
        }


        $resourcePath = '/peers/{id}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdDelete
     *
     * Delete Orthanc peer
     *
     * @param  string $id Identifier of the Orthanc peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdDelete'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function peersIdDelete($id, string $contentType = self::contentTypes['peersIdDelete'][0])
    {
        $this->peersIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation peersIdDeleteWithHttpInfo
     *
     * Delete Orthanc peer
     *
     * @param  string $id Identifier of the Orthanc peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdDelete'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['peersIdDelete'][0])
    {
        $request = $this->peersIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdDeleteAsync
     *
     * Delete Orthanc peer
     *
     * @param  string $id Identifier of the Orthanc peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdDeleteAsync($id, string $contentType = self::contentTypes['peersIdDelete'][0])
    {
        return $this->peersIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdDeleteAsyncWithHttpInfo
     *
     * Delete Orthanc peer
     *
     * @param  string $id Identifier of the Orthanc peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['peersIdDelete'][0])
    {
        $returnType = '';
        $request = $this->peersIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdDelete'
     *
     * @param  string $id Identifier of the Orthanc peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdDeleteRequest($id, string $contentType = self::contentTypes['peersIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdDelete'
            );
        }


        $resourcePath = '/peers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdGet
     *
     * List operations on peer
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function peersIdGet($id, string $contentType = self::contentTypes['peersIdGet'][0])
    {
        list($response) = $this->peersIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation peersIdGetWithHttpInfo
     *
     * List operations on peer
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdGetWithHttpInfo($id, string $contentType = self::contentTypes['peersIdGet'][0])
    {
        $request = $this->peersIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdGetAsync
     *
     * List operations on peer
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdGetAsync($id, string $contentType = self::contentTypes['peersIdGet'][0])
    {
        return $this->peersIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdGetAsyncWithHttpInfo
     *
     * List operations on peer
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['peersIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->peersIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdGet'
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdGetRequest($id, string $contentType = self::contentTypes['peersIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdGet'
            );
        }


        $resourcePath = '/peers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdPut
     *
     * Update Orthanc peer
     *
     * @param  string $id Identifier of the new/updated Orthanc peer (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdPutRequest $peersIdPutRequest peersIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function peersIdPut($id, $peersIdPutRequest = null, string $contentType = self::contentTypes['peersIdPut'][0])
    {
        $this->peersIdPutWithHttpInfo($id, $peersIdPutRequest, $contentType);
    }

    /**
     * Operation peersIdPutWithHttpInfo
     *
     * Update Orthanc peer
     *
     * @param  string $id Identifier of the new/updated Orthanc peer (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdPutRequest $peersIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdPut'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdPutWithHttpInfo($id, $peersIdPutRequest = null, string $contentType = self::contentTypes['peersIdPut'][0])
    {
        $request = $this->peersIdPutRequest($id, $peersIdPutRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdPutAsync
     *
     * Update Orthanc peer
     *
     * @param  string $id Identifier of the new/updated Orthanc peer (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdPutRequest $peersIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdPutAsync($id, $peersIdPutRequest = null, string $contentType = self::contentTypes['peersIdPut'][0])
    {
        return $this->peersIdPutAsyncWithHttpInfo($id, $peersIdPutRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdPutAsyncWithHttpInfo
     *
     * Update Orthanc peer
     *
     * @param  string $id Identifier of the new/updated Orthanc peer (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdPutRequest $peersIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdPutAsyncWithHttpInfo($id, $peersIdPutRequest = null, string $contentType = self::contentTypes['peersIdPut'][0])
    {
        $returnType = '';
        $request = $this->peersIdPutRequest($id, $peersIdPutRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdPut'
     *
     * @param  string $id Identifier of the new/updated Orthanc peer (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdPutRequest $peersIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdPutRequest($id, $peersIdPutRequest = null, string $contentType = self::contentTypes['peersIdPut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdPut'
            );
        }



        $resourcePath = '/peers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($peersIdPutRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($peersIdPutRequest));
            } else {
                $httpBody = $peersIdPutRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdStorePost
     *
     * Send to Orthanc peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdStorePostRequest $peersIdStorePostRequest peersIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStorePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response
     */
    public function peersIdStorePost($id, $peersIdStorePostRequest = null, string $contentType = self::contentTypes['peersIdStorePost'][0])
    {
        list($response) = $this->peersIdStorePostWithHttpInfo($id, $peersIdStorePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation peersIdStorePostWithHttpInfo
     *
     * Send to Orthanc peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdStorePostRequest $peersIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStorePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdStorePostWithHttpInfo($id, $peersIdStorePostRequest = null, string $contentType = self::contentTypes['peersIdStorePost'][0])
    {
        $request = $this->peersIdStorePostRequest($id, $peersIdStorePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdStorePostAsync
     *
     * Send to Orthanc peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdStorePostRequest $peersIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdStorePostAsync($id, $peersIdStorePostRequest = null, string $contentType = self::contentTypes['peersIdStorePost'][0])
    {
        return $this->peersIdStorePostAsyncWithHttpInfo($id, $peersIdStorePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdStorePostAsyncWithHttpInfo
     *
     * Send to Orthanc peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdStorePostRequest $peersIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdStorePostAsyncWithHttpInfo($id, $peersIdStorePostRequest = null, string $contentType = self::contentTypes['peersIdStorePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
        $request = $this->peersIdStorePostRequest($id, $peersIdStorePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdStorePost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\PeersIdStorePostRequest $peersIdStorePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdStorePostRequest($id, $peersIdStorePostRequest = null, string $contentType = self::contentTypes['peersIdStorePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdStorePost'
            );
        }



        $resourcePath = '/peers/{id}/store';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($peersIdStorePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($peersIdStorePostRequest));
            } else {
                $httpBody = $peersIdStorePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdStoreStraightPost
     *
     * Straight store to peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response
     */
    public function peersIdStoreStraightPost($id, $body = null, string $contentType = self::contentTypes['peersIdStoreStraightPost'][0])
    {
        list($response) = $this->peersIdStoreStraightPostWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation peersIdStoreStraightPostWithHttpInfo
     *
     * Straight store to peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdStoreStraightPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['peersIdStoreStraightPost'][0])
    {
        $request = $this->peersIdStoreStraightPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdStoreStraightPostAsync
     *
     * Straight store to peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdStoreStraightPostAsync($id, $body = null, string $contentType = self::contentTypes['peersIdStoreStraightPost'][0])
    {
        return $this->peersIdStoreStraightPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdStoreStraightPostAsyncWithHttpInfo
     *
     * Straight store to peer
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdStoreStraightPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['peersIdStoreStraightPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\PeersIdStoreStraightPost200Response';
        $request = $this->peersIdStoreStraightPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdStoreStraightPost'
     *
     * @param  string $id Identifier of the modality of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdStoreStraightPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdStoreStraightPostRequest($id, $body = null, string $contentType = self::contentTypes['peersIdStoreStraightPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdStoreStraightPost'
            );
        }



        $resourcePath = '/peers/{id}/store-straight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation peersIdSystemGet
     *
     * Get peer system information
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdSystemGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function peersIdSystemGet($id, string $contentType = self::contentTypes['peersIdSystemGet'][0])
    {
        list($response) = $this->peersIdSystemGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation peersIdSystemGetWithHttpInfo
     *
     * Get peer system information
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdSystemGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function peersIdSystemGetWithHttpInfo($id, string $contentType = self::contentTypes['peersIdSystemGet'][0])
    {
        $request = $this->peersIdSystemGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation peersIdSystemGetAsync
     *
     * Get peer system information
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdSystemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdSystemGetAsync($id, string $contentType = self::contentTypes['peersIdSystemGet'][0])
    {
        return $this->peersIdSystemGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation peersIdSystemGetAsyncWithHttpInfo
     *
     * Get peer system information
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdSystemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function peersIdSystemGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['peersIdSystemGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->peersIdSystemGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'peersIdSystemGet'
     *
     * @param  string $id Identifier of the peer of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['peersIdSystemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function peersIdSystemGetRequest($id, string $contentType = self::contentTypes['peersIdSystemGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling peersIdSystemGet'
            );
        }


        $resourcePath = '/peers/{id}/system';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesGet
     *
     * List query/retrieve operations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesGet(string $contentType = self::contentTypes['queriesGet'][0])
    {
        list($response) = $this->queriesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation queriesGetWithHttpInfo
     *
     * List query/retrieve operations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesGetWithHttpInfo(string $contentType = self::contentTypes['queriesGet'][0])
    {
        $request = $this->queriesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesGetAsync
     *
     * List query/retrieve operations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesGetAsync(string $contentType = self::contentTypes['queriesGet'][0])
    {
        return $this->queriesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesGetAsyncWithHttpInfo
     *
     * List query/retrieve operations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['queriesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesGetRequest(string $contentType = self::contentTypes['queriesGet'][0])
    {


        $resourcePath = '/queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersGet
     *
     * List answers to a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $expand If present, retrieve detailed information about the individual answers (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdAnswersGet($id, $expand = null, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersGet'][0])
    {
        list($response) = $this->queriesIdAnswersGetWithHttpInfo($id, $expand, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersGetWithHttpInfo
     *
     * List answers to a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $expand If present, retrieve detailed information about the individual answers (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersGetWithHttpInfo($id, $expand = null, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersGet'][0])
    {
        $request = $this->queriesIdAnswersGetRequest($id, $expand, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersGetAsync
     *
     * List answers to a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $expand If present, retrieve detailed information about the individual answers (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersGetAsync($id, $expand = null, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersGet'][0])
    {
        return $this->queriesIdAnswersGetAsyncWithHttpInfo($id, $expand, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersGetAsyncWithHttpInfo
     *
     * List answers to a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $expand If present, retrieve detailed information about the individual answers (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersGetAsyncWithHttpInfo($id, $expand = null, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdAnswersGetRequest($id, $expand, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $expand If present, retrieve detailed information about the individual answers (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersGetRequest($id, $expand = null, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersGet'
            );
        }





        $resourcePath = '/queries/{id}/answers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersIndexContentGet
     *
     * Get one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexContentGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdAnswersIndexContentGet($id, $index, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersIndexContentGet'][0])
    {
        list($response) = $this->queriesIdAnswersIndexContentGetWithHttpInfo($id, $index, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersIndexContentGetWithHttpInfo
     *
     * Get one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexContentGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersIndexContentGetWithHttpInfo($id, $index, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersIndexContentGet'][0])
    {
        $request = $this->queriesIdAnswersIndexContentGetRequest($id, $index, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersIndexContentGetAsync
     *
     * Get one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexContentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexContentGetAsync($id, $index, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersIndexContentGet'][0])
    {
        return $this->queriesIdAnswersIndexContentGetAsyncWithHttpInfo($id, $index, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersIndexContentGetAsyncWithHttpInfo
     *
     * Get one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexContentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexContentGetAsyncWithHttpInfo($id, $index, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersIndexContentGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdAnswersIndexContentGetRequest($id, $index, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersIndexContentGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexContentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersIndexContentGetRequest($id, $index, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdAnswersIndexContentGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersIndexContentGet'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling queriesIdAnswersIndexContentGet'
            );
        }




        $resourcePath = '/queries/{id}/answers/{index}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersIndexGet
     *
     * List operations on an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdAnswersIndexGet($id, $index, string $contentType = self::contentTypes['queriesIdAnswersIndexGet'][0])
    {
        list($response) = $this->queriesIdAnswersIndexGetWithHttpInfo($id, $index, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersIndexGetWithHttpInfo
     *
     * List operations on an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersIndexGetWithHttpInfo($id, $index, string $contentType = self::contentTypes['queriesIdAnswersIndexGet'][0])
    {
        $request = $this->queriesIdAnswersIndexGetRequest($id, $index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersIndexGetAsync
     *
     * List operations on an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexGetAsync($id, $index, string $contentType = self::contentTypes['queriesIdAnswersIndexGet'][0])
    {
        return $this->queriesIdAnswersIndexGetAsyncWithHttpInfo($id, $index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersIndexGetAsyncWithHttpInfo
     *
     * List operations on an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexGetAsyncWithHttpInfo($id, $index, string $contentType = self::contentTypes['queriesIdAnswersIndexGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdAnswersIndexGetRequest($id, $index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersIndexGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersIndexGetRequest($id, $index, string $contentType = self::contentTypes['queriesIdAnswersIndexGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersIndexGet'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling queriesIdAnswersIndexGet'
            );
        }


        $resourcePath = '/queries/{id}/answers/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersIndexQueryInstancesPost
     *
     * Query the child instances of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response
     */
    public function queriesIdAnswersIndexQueryInstancesPost($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'][0])
    {
        list($response) = $this->queriesIdAnswersIndexQueryInstancesPostWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersIndexQueryInstancesPostWithHttpInfo
     *
     * Query the child instances of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersIndexQueryInstancesPostWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'][0])
    {
        $request = $this->queriesIdAnswersIndexQueryInstancesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersIndexQueryInstancesPostAsync
     *
     * Query the child instances of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexQueryInstancesPostAsync($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'][0])
    {
        return $this->queriesIdAnswersIndexQueryInstancesPostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersIndexQueryInstancesPostAsyncWithHttpInfo
     *
     * Query the child instances of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexQueryInstancesPostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
        $request = $this->queriesIdAnswersIndexQueryInstancesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersIndexQueryInstancesPost'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersIndexQueryInstancesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryInstancesPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersIndexQueryInstancesPost'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling queriesIdAnswersIndexQueryInstancesPost'
            );
        }



        $resourcePath = '/queries/{id}/answers/{index}/query-instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queriesIdAnswersIndexQueryInstancesPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queriesIdAnswersIndexQueryInstancesPostRequest));
            } else {
                $httpBody = $queriesIdAnswersIndexQueryInstancesPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersIndexQuerySeriesPost
     *
     * Query the child series of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response
     */
    public function queriesIdAnswersIndexQuerySeriesPost($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'][0])
    {
        list($response) = $this->queriesIdAnswersIndexQuerySeriesPostWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersIndexQuerySeriesPostWithHttpInfo
     *
     * Query the child series of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersIndexQuerySeriesPostWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'][0])
    {
        $request = $this->queriesIdAnswersIndexQuerySeriesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersIndexQuerySeriesPostAsync
     *
     * Query the child series of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexQuerySeriesPostAsync($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'][0])
    {
        return $this->queriesIdAnswersIndexQuerySeriesPostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersIndexQuerySeriesPostAsyncWithHttpInfo
     *
     * Query the child series of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexQuerySeriesPostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
        $request = $this->queriesIdAnswersIndexQuerySeriesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersIndexQuerySeriesPost'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersIndexQuerySeriesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQuerySeriesPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersIndexQuerySeriesPost'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling queriesIdAnswersIndexQuerySeriesPost'
            );
        }



        $resourcePath = '/queries/{id}/answers/{index}/query-series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queriesIdAnswersIndexQueryInstancesPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queriesIdAnswersIndexQueryInstancesPostRequest));
            } else {
                $httpBody = $queriesIdAnswersIndexQueryInstancesPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersIndexQueryStudiesPost
     *
     * Query the child studies of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response
     */
    public function queriesIdAnswersIndexQueryStudiesPost($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'][0])
    {
        list($response) = $this->queriesIdAnswersIndexQueryStudiesPostWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersIndexQueryStudiesPostWithHttpInfo
     *
     * Query the child studies of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersIndexQueryStudiesPostWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'][0])
    {
        $request = $this->queriesIdAnswersIndexQueryStudiesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersIndexQueryStudiesPostAsync
     *
     * Query the child studies of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexQueryStudiesPostAsync($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'][0])
    {
        return $this->queriesIdAnswersIndexQueryStudiesPostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersIndexQueryStudiesPostAsyncWithHttpInfo
     *
     * Query the child studies of an answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexQueryStudiesPostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdQueryPost200Response';
        $request = $this->queriesIdAnswersIndexQueryStudiesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersIndexQueryStudiesPost'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexQueryInstancesPostRequest $queriesIdAnswersIndexQueryInstancesPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersIndexQueryStudiesPostRequest($id, $index, $queriesIdAnswersIndexQueryInstancesPostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexQueryStudiesPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersIndexQueryStudiesPost'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling queriesIdAnswersIndexQueryStudiesPost'
            );
        }



        $resourcePath = '/queries/{id}/answers/{index}/query-studies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queriesIdAnswersIndexQueryInstancesPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queriesIdAnswersIndexQueryInstancesPostRequest));
            } else {
                $httpBody = $queriesIdAnswersIndexQueryInstancesPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdAnswersIndexRetrievePost
     *
     * Retrieve one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexRetrievePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response
     */
    public function queriesIdAnswersIndexRetrievePost($id, $index, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexRetrievePost'][0])
    {
        list($response) = $this->queriesIdAnswersIndexRetrievePostWithHttpInfo($id, $index, $queriesIdAnswersIndexRetrievePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdAnswersIndexRetrievePostWithHttpInfo
     *
     * Retrieve one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexRetrievePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdAnswersIndexRetrievePostWithHttpInfo($id, $index, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexRetrievePost'][0])
    {
        $request = $this->queriesIdAnswersIndexRetrievePostRequest($id, $index, $queriesIdAnswersIndexRetrievePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdAnswersIndexRetrievePostAsync
     *
     * Retrieve one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexRetrievePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexRetrievePostAsync($id, $index, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexRetrievePost'][0])
    {
        return $this->queriesIdAnswersIndexRetrievePostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexRetrievePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdAnswersIndexRetrievePostAsyncWithHttpInfo
     *
     * Retrieve one answer
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexRetrievePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdAnswersIndexRetrievePostAsyncWithHttpInfo($id, $index, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexRetrievePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
        $request = $this->queriesIdAnswersIndexRetrievePostRequest($id, $index, $queriesIdAnswersIndexRetrievePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdAnswersIndexRetrievePost'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $index Index of the answer (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdAnswersIndexRetrievePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdAnswersIndexRetrievePostRequest($id, $index, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdAnswersIndexRetrievePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdAnswersIndexRetrievePost'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling queriesIdAnswersIndexRetrievePost'
            );
        }



        $resourcePath = '/queries/{id}/answers/{index}/retrieve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queriesIdAnswersIndexRetrievePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queriesIdAnswersIndexRetrievePostRequest));
            } else {
                $httpBody = $queriesIdAnswersIndexRetrievePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdDelete
     *
     * Delete a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdDelete'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function queriesIdDelete($id, string $contentType = self::contentTypes['queriesIdDelete'][0])
    {
        $this->queriesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation queriesIdDeleteWithHttpInfo
     *
     * Delete a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdDelete'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdDelete'][0])
    {
        $request = $this->queriesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdDeleteAsync
     *
     * Delete a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdDeleteAsync($id, string $contentType = self::contentTypes['queriesIdDelete'][0])
    {
        return $this->queriesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdDeleteAsyncWithHttpInfo
     *
     * Delete a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdDelete'][0])
    {
        $returnType = '';
        $request = $this->queriesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdDelete'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdDeleteRequest($id, string $contentType = self::contentTypes['queriesIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdDelete'
            );
        }


        $resourcePath = '/queries/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdGet
     *
     * List operations on a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdGet($id, string $contentType = self::contentTypes['queriesIdGet'][0])
    {
        list($response) = $this->queriesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdGetWithHttpInfo
     *
     * List operations on a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdGetWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdGet'][0])
    {
        $request = $this->queriesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdGetAsync
     *
     * List operations on a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdGetAsync($id, string $contentType = self::contentTypes['queriesIdGet'][0])
    {
        return $this->queriesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdGetAsyncWithHttpInfo
     *
     * List operations on a query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdGetRequest($id, string $contentType = self::contentTypes['queriesIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdGet'
            );
        }


        $resourcePath = '/queries/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdLevelGet
     *
     * Get level of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdLevelGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdLevelGet($id, string $contentType = self::contentTypes['queriesIdLevelGet'][0])
    {
        list($response) = $this->queriesIdLevelGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdLevelGetWithHttpInfo
     *
     * Get level of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdLevelGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdLevelGetWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdLevelGet'][0])
    {
        $request = $this->queriesIdLevelGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdLevelGetAsync
     *
     * Get level of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdLevelGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdLevelGetAsync($id, string $contentType = self::contentTypes['queriesIdLevelGet'][0])
    {
        return $this->queriesIdLevelGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdLevelGetAsyncWithHttpInfo
     *
     * Get level of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdLevelGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdLevelGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdLevelGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdLevelGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdLevelGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdLevelGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdLevelGetRequest($id, string $contentType = self::contentTypes['queriesIdLevelGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdLevelGet'
            );
        }


        $resourcePath = '/queries/{id}/level';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdModalityGet
     *
     * Get modality of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdModalityGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdModalityGet($id, string $contentType = self::contentTypes['queriesIdModalityGet'][0])
    {
        list($response) = $this->queriesIdModalityGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdModalityGetWithHttpInfo
     *
     * Get modality of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdModalityGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdModalityGetWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdModalityGet'][0])
    {
        $request = $this->queriesIdModalityGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdModalityGetAsync
     *
     * Get modality of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdModalityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdModalityGetAsync($id, string $contentType = self::contentTypes['queriesIdModalityGet'][0])
    {
        return $this->queriesIdModalityGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdModalityGetAsyncWithHttpInfo
     *
     * Get modality of original query
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdModalityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdModalityGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['queriesIdModalityGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdModalityGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdModalityGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdModalityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdModalityGetRequest($id, string $contentType = self::contentTypes['queriesIdModalityGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdModalityGet'
            );
        }


        $resourcePath = '/queries/{id}/modality';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdQueryGet
     *
     * Get original query arguments
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdQueryGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function queriesIdQueryGet($id, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdQueryGet'][0])
    {
        list($response) = $this->queriesIdQueryGetWithHttpInfo($id, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdQueryGetWithHttpInfo
     *
     * Get original query arguments
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdQueryGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdQueryGetWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdQueryGet'][0])
    {
        $request = $this->queriesIdQueryGetRequest($id, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdQueryGetAsync
     *
     * Get original query arguments
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdQueryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdQueryGetAsync($id, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdQueryGet'][0])
    {
        return $this->queriesIdQueryGetAsyncWithHttpInfo($id, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdQueryGetAsyncWithHttpInfo
     *
     * Get original query arguments
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdQueryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdQueryGetAsyncWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdQueryGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->queriesIdQueryGetRequest($id, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdQueryGet'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdQueryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdQueryGetRequest($id, $short = null, $simplify = null, string $contentType = self::contentTypes['queriesIdQueryGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdQueryGet'
            );
        }




        $resourcePath = '/queries/{id}/query';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queriesIdRetrievePost
     *
     * Retrieve all answers
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdRetrievePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response
     */
    public function queriesIdRetrievePost($id, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdRetrievePost'][0])
    {
        list($response) = $this->queriesIdRetrievePostWithHttpInfo($id, $queriesIdAnswersIndexRetrievePostRequest, $contentType);
        return $response;
    }

    /**
     * Operation queriesIdRetrievePostWithHttpInfo
     *
     * Retrieve all answers
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdRetrievePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function queriesIdRetrievePostWithHttpInfo($id, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdRetrievePost'][0])
    {
        $request = $this->queriesIdRetrievePostRequest($id, $queriesIdAnswersIndexRetrievePostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queriesIdRetrievePostAsync
     *
     * Retrieve all answers
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdRetrievePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdRetrievePostAsync($id, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdRetrievePost'][0])
    {
        return $this->queriesIdRetrievePostAsyncWithHttpInfo($id, $queriesIdAnswersIndexRetrievePostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queriesIdRetrievePostAsyncWithHttpInfo
     *
     * Retrieve all answers
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdRetrievePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queriesIdRetrievePostAsyncWithHttpInfo($id, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdRetrievePost'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\ModalitiesIdMovePost200Response';
        $request = $this->queriesIdRetrievePostRequest($id, $queriesIdAnswersIndexRetrievePostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queriesIdRetrievePost'
     *
     * @param  string $id Identifier of the query of interest (required)
     * @param  \Aurabx\OrthancPHP\Model\QueriesIdAnswersIndexRetrievePostRequest $queriesIdAnswersIndexRetrievePostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queriesIdRetrievePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queriesIdRetrievePostRequest($id, $queriesIdAnswersIndexRetrievePostRequest = null, string $contentType = self::contentTypes['queriesIdRetrievePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling queriesIdRetrievePost'
            );
        }



        $resourcePath = '/queries/{id}/retrieve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queriesIdAnswersIndexRetrievePostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queriesIdAnswersIndexRetrievePostRequest));
            } else {
                $httpBody = $queriesIdAnswersIndexRetrievePostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageCommitmentIdGet
     *
     * Get storage commitment report
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response
     */
    public function storageCommitmentIdGet($id, string $contentType = self::contentTypes['storageCommitmentIdGet'][0])
    {
        list($response) = $this->storageCommitmentIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation storageCommitmentIdGetWithHttpInfo
     *
     * Get storage commitment report
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdGet'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageCommitmentIdGetWithHttpInfo($id, string $contentType = self::contentTypes['storageCommitmentIdGet'][0])
    {
        $request = $this->storageCommitmentIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageCommitmentIdGetAsync
     *
     * Get storage commitment report
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageCommitmentIdGetAsync($id, string $contentType = self::contentTypes['storageCommitmentIdGet'][0])
    {
        return $this->storageCommitmentIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageCommitmentIdGetAsyncWithHttpInfo
     *
     * Get storage commitment report
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageCommitmentIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['storageCommitmentIdGet'][0])
    {
        $returnType = '\Aurabx\OrthancPHP\Model\StorageCommitmentIdGet200Response';
        $request = $this->storageCommitmentIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageCommitmentIdGet'
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageCommitmentIdGetRequest($id, string $contentType = self::contentTypes['storageCommitmentIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling storageCommitmentIdGet'
            );
        }


        $resourcePath = '/storage-commitment/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageCommitmentIdRemovePost
     *
     * Remove after storage commitment
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdRemovePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storageCommitmentIdRemovePost($id, string $contentType = self::contentTypes['storageCommitmentIdRemovePost'][0])
    {
        $this->storageCommitmentIdRemovePostWithHttpInfo($id, $contentType);
    }

    /**
     * Operation storageCommitmentIdRemovePostWithHttpInfo
     *
     * Remove after storage commitment
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdRemovePost'] to see the possible values for this operation
     *
     * @throws \Aurabx\OrthancPHP\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageCommitmentIdRemovePostWithHttpInfo($id, string $contentType = self::contentTypes['storageCommitmentIdRemovePost'][0])
    {
        $request = $this->storageCommitmentIdRemovePostRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation storageCommitmentIdRemovePostAsync
     *
     * Remove after storage commitment
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdRemovePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageCommitmentIdRemovePostAsync($id, string $contentType = self::contentTypes['storageCommitmentIdRemovePost'][0])
    {
        return $this->storageCommitmentIdRemovePostAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageCommitmentIdRemovePostAsyncWithHttpInfo
     *
     * Remove after storage commitment
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdRemovePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageCommitmentIdRemovePostAsyncWithHttpInfo($id, string $contentType = self::contentTypes['storageCommitmentIdRemovePost'][0])
    {
        $returnType = '';
        $request = $this->storageCommitmentIdRemovePostRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageCommitmentIdRemovePost'
     *
     * @param  string $id Identifier of the storage commitment report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageCommitmentIdRemovePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageCommitmentIdRemovePostRequest($id, string $contentType = self::contentTypes['storageCommitmentIdRemovePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling storageCommitmentIdRemovePost'
            );
        }


        $resourcePath = '/storage-commitment/{id}/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
