<?php
/**
 * SystemGet200Response
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Aurabx\OrthancPHP
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://orthanc.uclouvain.be/book/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://orthanc.uclouvain.be/book/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.12.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Aurabx\OrthancPHP\Model;

use \ArrayAccess;
use \Aurabx\OrthancPHP\ObjectSerializer;

/**
 * SystemGet200Response Class Doc Comment
 *
 * @category Class
 * @description 
 * @package  Aurabx\OrthancPHP
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SystemGet200Response implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = '_system_get_200_response';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'apiVersion' => 'float',
        'checkRevisions' => 'bool',
        'databaseBackendPlugin' => 'string',
        'databaseServerIdentifier' => 'string',
        'databaseVersion' => 'float',
        'dicomAet' => 'string',
        'dicomPort' => 'float',
        'hasLabels' => 'bool',
        'httpPort' => 'float',
        'ingestTranscoding' => 'string',
        'isHttpServerSecure' => 'bool',
        'mainDicomTags' => 'object',
        'maximumPatientCount' => 'float',
        'maximumStorageMode' => 'string',
        'maximumStorageSize' => 'float',
        'name' => 'string',
        'overwriteInstances' => 'bool',
        'pluginsEnabled' => 'bool',
        'storageAreaPlugin' => 'string',
        'storageCompression' => 'bool',
        'userMetadata' => 'object',
        'version' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'apiVersion' => null,
        'checkRevisions' => null,
        'databaseBackendPlugin' => null,
        'databaseServerIdentifier' => null,
        'databaseVersion' => null,
        'dicomAet' => null,
        'dicomPort' => null,
        'hasLabels' => null,
        'httpPort' => null,
        'ingestTranscoding' => null,
        'isHttpServerSecure' => null,
        'mainDicomTags' => null,
        'maximumPatientCount' => null,
        'maximumStorageMode' => null,
        'maximumStorageSize' => null,
        'name' => null,
        'overwriteInstances' => null,
        'pluginsEnabled' => null,
        'storageAreaPlugin' => null,
        'storageCompression' => null,
        'userMetadata' => null,
        'version' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'apiVersion' => false,
        'checkRevisions' => false,
        'databaseBackendPlugin' => false,
        'databaseServerIdentifier' => false,
        'databaseVersion' => false,
        'dicomAet' => false,
        'dicomPort' => false,
        'hasLabels' => false,
        'httpPort' => false,
        'ingestTranscoding' => false,
        'isHttpServerSecure' => false,
        'mainDicomTags' => false,
        'maximumPatientCount' => false,
        'maximumStorageMode' => false,
        'maximumStorageSize' => false,
        'name' => false,
        'overwriteInstances' => false,
        'pluginsEnabled' => false,
        'storageAreaPlugin' => false,
        'storageCompression' => false,
        'userMetadata' => false,
        'version' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'apiVersion' => 'ApiVersion',
        'checkRevisions' => 'CheckRevisions',
        'databaseBackendPlugin' => 'DatabaseBackendPlugin',
        'databaseServerIdentifier' => 'DatabaseServerIdentifier',
        'databaseVersion' => 'DatabaseVersion',
        'dicomAet' => 'DicomAet',
        'dicomPort' => 'DicomPort',
        'hasLabels' => 'HasLabels',
        'httpPort' => 'HttpPort',
        'ingestTranscoding' => 'IngestTranscoding',
        'isHttpServerSecure' => 'IsHttpServerSecure',
        'mainDicomTags' => 'MainDicomTags',
        'maximumPatientCount' => 'MaximumPatientCount',
        'maximumStorageMode' => 'MaximumStorageMode',
        'maximumStorageSize' => 'MaximumStorageSize',
        'name' => 'Name',
        'overwriteInstances' => 'OverwriteInstances',
        'pluginsEnabled' => 'PluginsEnabled',
        'storageAreaPlugin' => 'StorageAreaPlugin',
        'storageCompression' => 'StorageCompression',
        'userMetadata' => 'UserMetadata',
        'version' => 'Version'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'apiVersion' => 'setApiVersion',
        'checkRevisions' => 'setCheckRevisions',
        'databaseBackendPlugin' => 'setDatabaseBackendPlugin',
        'databaseServerIdentifier' => 'setDatabaseServerIdentifier',
        'databaseVersion' => 'setDatabaseVersion',
        'dicomAet' => 'setDicomAet',
        'dicomPort' => 'setDicomPort',
        'hasLabels' => 'setHasLabels',
        'httpPort' => 'setHttpPort',
        'ingestTranscoding' => 'setIngestTranscoding',
        'isHttpServerSecure' => 'setIsHttpServerSecure',
        'mainDicomTags' => 'setMainDicomTags',
        'maximumPatientCount' => 'setMaximumPatientCount',
        'maximumStorageMode' => 'setMaximumStorageMode',
        'maximumStorageSize' => 'setMaximumStorageSize',
        'name' => 'setName',
        'overwriteInstances' => 'setOverwriteInstances',
        'pluginsEnabled' => 'setPluginsEnabled',
        'storageAreaPlugin' => 'setStorageAreaPlugin',
        'storageCompression' => 'setStorageCompression',
        'userMetadata' => 'setUserMetadata',
        'version' => 'setVersion'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'apiVersion' => 'getApiVersion',
        'checkRevisions' => 'getCheckRevisions',
        'databaseBackendPlugin' => 'getDatabaseBackendPlugin',
        'databaseServerIdentifier' => 'getDatabaseServerIdentifier',
        'databaseVersion' => 'getDatabaseVersion',
        'dicomAet' => 'getDicomAet',
        'dicomPort' => 'getDicomPort',
        'hasLabels' => 'getHasLabels',
        'httpPort' => 'getHttpPort',
        'ingestTranscoding' => 'getIngestTranscoding',
        'isHttpServerSecure' => 'getIsHttpServerSecure',
        'mainDicomTags' => 'getMainDicomTags',
        'maximumPatientCount' => 'getMaximumPatientCount',
        'maximumStorageMode' => 'getMaximumStorageMode',
        'maximumStorageSize' => 'getMaximumStorageSize',
        'name' => 'getName',
        'overwriteInstances' => 'getOverwriteInstances',
        'pluginsEnabled' => 'getPluginsEnabled',
        'storageAreaPlugin' => 'getStorageAreaPlugin',
        'storageCompression' => 'getStorageCompression',
        'userMetadata' => 'getUserMetadata',
        'version' => 'getVersion'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('apiVersion', $data ?? [], null);
        $this->setIfExists('checkRevisions', $data ?? [], null);
        $this->setIfExists('databaseBackendPlugin', $data ?? [], null);
        $this->setIfExists('databaseServerIdentifier', $data ?? [], null);
        $this->setIfExists('databaseVersion', $data ?? [], null);
        $this->setIfExists('dicomAet', $data ?? [], null);
        $this->setIfExists('dicomPort', $data ?? [], null);
        $this->setIfExists('hasLabels', $data ?? [], null);
        $this->setIfExists('httpPort', $data ?? [], null);
        $this->setIfExists('ingestTranscoding', $data ?? [], null);
        $this->setIfExists('isHttpServerSecure', $data ?? [], null);
        $this->setIfExists('mainDicomTags', $data ?? [], null);
        $this->setIfExists('maximumPatientCount', $data ?? [], null);
        $this->setIfExists('maximumStorageMode', $data ?? [], null);
        $this->setIfExists('maximumStorageSize', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('overwriteInstances', $data ?? [], null);
        $this->setIfExists('pluginsEnabled', $data ?? [], null);
        $this->setIfExists('storageAreaPlugin', $data ?? [], null);
        $this->setIfExists('storageCompression', $data ?? [], null);
        $this->setIfExists('userMetadata', $data ?? [], null);
        $this->setIfExists('version', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets apiVersion
     *
     * @return float|null
     */
    public function getApiVersion()
    {
        return $this->container['apiVersion'];
    }

    /**
     * Sets apiVersion
     *
     * @param float|null $apiVersion Version of the REST API
     *
     * @return self
     */
    public function setApiVersion($apiVersion)
    {
        if (is_null($apiVersion)) {
            throw new \InvalidArgumentException('non-nullable apiVersion cannot be null');
        }
        $this->container['apiVersion'] = $apiVersion;

        return $this;
    }

    /**
     * Gets checkRevisions
     *
     * @return bool|null
     */
    public function getCheckRevisions()
    {
        return $this->container['checkRevisions'];
    }

    /**
     * Sets checkRevisions
     *
     * @param bool|null $checkRevisions Whether Orthanc handle revisions of metadata and attachments to deal with multiple writers (new in Orthanc 1.9.2)
     *
     * @return self
     */
    public function setCheckRevisions($checkRevisions)
    {
        if (is_null($checkRevisions)) {
            throw new \InvalidArgumentException('non-nullable checkRevisions cannot be null');
        }
        $this->container['checkRevisions'] = $checkRevisions;

        return $this;
    }

    /**
     * Gets databaseBackendPlugin
     *
     * @return string|null
     */
    public function getDatabaseBackendPlugin()
    {
        return $this->container['databaseBackendPlugin'];
    }

    /**
     * Sets databaseBackendPlugin
     *
     * @param string|null $databaseBackendPlugin Information about the installed database index plugin (`null` if no such plugin is installed)
     *
     * @return self
     */
    public function setDatabaseBackendPlugin($databaseBackendPlugin)
    {
        if (is_null($databaseBackendPlugin)) {
            throw new \InvalidArgumentException('non-nullable databaseBackendPlugin cannot be null');
        }
        $this->container['databaseBackendPlugin'] = $databaseBackendPlugin;

        return $this;
    }

    /**
     * Gets databaseServerIdentifier
     *
     * @return string|null
     */
    public function getDatabaseServerIdentifier()
    {
        return $this->container['databaseServerIdentifier'];
    }

    /**
     * Sets databaseServerIdentifier
     *
     * @param string|null $databaseServerIdentifier ID of the server in the database (when running multiple Orthanc on the same DB)
     *
     * @return self
     */
    public function setDatabaseServerIdentifier($databaseServerIdentifier)
    {
        if (is_null($databaseServerIdentifier)) {
            throw new \InvalidArgumentException('non-nullable databaseServerIdentifier cannot be null');
        }
        $this->container['databaseServerIdentifier'] = $databaseServerIdentifier;

        return $this;
    }

    /**
     * Gets databaseVersion
     *
     * @return float|null
     */
    public function getDatabaseVersion()
    {
        return $this->container['databaseVersion'];
    }

    /**
     * Sets databaseVersion
     *
     * @param float|null $databaseVersion Version of the database: https://orthanc.uclouvain.be/book/developers/db-versioning.html
     *
     * @return self
     */
    public function setDatabaseVersion($databaseVersion)
    {
        if (is_null($databaseVersion)) {
            throw new \InvalidArgumentException('non-nullable databaseVersion cannot be null');
        }
        $this->container['databaseVersion'] = $databaseVersion;

        return $this;
    }

    /**
     * Gets dicomAet
     *
     * @return string|null
     */
    public function getDicomAet()
    {
        return $this->container['dicomAet'];
    }

    /**
     * Sets dicomAet
     *
     * @param string|null $dicomAet The DICOM AET of Orthanc
     *
     * @return self
     */
    public function setDicomAet($dicomAet)
    {
        if (is_null($dicomAet)) {
            throw new \InvalidArgumentException('non-nullable dicomAet cannot be null');
        }
        $this->container['dicomAet'] = $dicomAet;

        return $this;
    }

    /**
     * Gets dicomPort
     *
     * @return float|null
     */
    public function getDicomPort()
    {
        return $this->container['dicomPort'];
    }

    /**
     * Sets dicomPort
     *
     * @param float|null $dicomPort The port to the DICOM server of Orthanc
     *
     * @return self
     */
    public function setDicomPort($dicomPort)
    {
        if (is_null($dicomPort)) {
            throw new \InvalidArgumentException('non-nullable dicomPort cannot be null');
        }
        $this->container['dicomPort'] = $dicomPort;

        return $this;
    }

    /**
     * Gets hasLabels
     *
     * @return bool|null
     */
    public function getHasLabels()
    {
        return $this->container['hasLabels'];
    }

    /**
     * Sets hasLabels
     *
     * @param bool|null $hasLabels Whether the database back-end supports labels (new in Orthanc 1.12.0)
     *
     * @return self
     */
    public function setHasLabels($hasLabels)
    {
        if (is_null($hasLabels)) {
            throw new \InvalidArgumentException('non-nullable hasLabels cannot be null');
        }
        $this->container['hasLabels'] = $hasLabels;

        return $this;
    }

    /**
     * Gets httpPort
     *
     * @return float|null
     */
    public function getHttpPort()
    {
        return $this->container['httpPort'];
    }

    /**
     * Sets httpPort
     *
     * @param float|null $httpPort The port to the HTTP server of Orthanc
     *
     * @return self
     */
    public function setHttpPort($httpPort)
    {
        if (is_null($httpPort)) {
            throw new \InvalidArgumentException('non-nullable httpPort cannot be null');
        }
        $this->container['httpPort'] = $httpPort;

        return $this;
    }

    /**
     * Gets ingestTranscoding
     *
     * @return string|null
     */
    public function getIngestTranscoding()
    {
        return $this->container['ingestTranscoding'];
    }

    /**
     * Sets ingestTranscoding
     *
     * @param string|null $ingestTranscoding Whether instances are transcoded when ingested into Orthanc (`` if no transcoding is performed) (new in Orthanc 1.11.0)
     *
     * @return self
     */
    public function setIngestTranscoding($ingestTranscoding)
    {
        if (is_null($ingestTranscoding)) {
            throw new \InvalidArgumentException('non-nullable ingestTranscoding cannot be null');
        }
        $this->container['ingestTranscoding'] = $ingestTranscoding;

        return $this;
    }

    /**
     * Gets isHttpServerSecure
     *
     * @return bool|null
     */
    public function getIsHttpServerSecure()
    {
        return $this->container['isHttpServerSecure'];
    }

    /**
     * Sets isHttpServerSecure
     *
     * @param bool|null $isHttpServerSecure Whether the REST API is properly secured (assuming no reverse proxy is in use): https://orthanc.uclouvain.be/book/faq/security.html#securing-the-http-server
     *
     * @return self
     */
    public function setIsHttpServerSecure($isHttpServerSecure)
    {
        if (is_null($isHttpServerSecure)) {
            throw new \InvalidArgumentException('non-nullable isHttpServerSecure cannot be null');
        }
        $this->container['isHttpServerSecure'] = $isHttpServerSecure;

        return $this;
    }

    /**
     * Gets mainDicomTags
     *
     * @return object|null
     */
    public function getMainDicomTags()
    {
        return $this->container['mainDicomTags'];
    }

    /**
     * Sets mainDicomTags
     *
     * @param object|null $mainDicomTags The list of MainDicomTags saved in DB for each resource level (new in Orthanc 1.11.0)
     *
     * @return self
     */
    public function setMainDicomTags($mainDicomTags)
    {
        if (is_null($mainDicomTags)) {
            throw new \InvalidArgumentException('non-nullable mainDicomTags cannot be null');
        }
        $this->container['mainDicomTags'] = $mainDicomTags;

        return $this;
    }

    /**
     * Gets maximumPatientCount
     *
     * @return float|null
     */
    public function getMaximumPatientCount()
    {
        return $this->container['maximumPatientCount'];
    }

    /**
     * Sets maximumPatientCount
     *
     * @param float|null $maximumPatientCount The configured MaximumPatientCount (new in Orthanc 1.12.4)
     *
     * @return self
     */
    public function setMaximumPatientCount($maximumPatientCount)
    {
        if (is_null($maximumPatientCount)) {
            throw new \InvalidArgumentException('non-nullable maximumPatientCount cannot be null');
        }
        $this->container['maximumPatientCount'] = $maximumPatientCount;

        return $this;
    }

    /**
     * Gets maximumStorageMode
     *
     * @return string|null
     */
    public function getMaximumStorageMode()
    {
        return $this->container['maximumStorageMode'];
    }

    /**
     * Sets maximumStorageMode
     *
     * @param string|null $maximumStorageMode The configured MaximumStorageMode (new in Orthanc 1.11.3)
     *
     * @return self
     */
    public function setMaximumStorageMode($maximumStorageMode)
    {
        if (is_null($maximumStorageMode)) {
            throw new \InvalidArgumentException('non-nullable maximumStorageMode cannot be null');
        }
        $this->container['maximumStorageMode'] = $maximumStorageMode;

        return $this;
    }

    /**
     * Gets maximumStorageSize
     *
     * @return float|null
     */
    public function getMaximumStorageSize()
    {
        return $this->container['maximumStorageSize'];
    }

    /**
     * Sets maximumStorageSize
     *
     * @param float|null $maximumStorageSize The configured MaximumStorageSize in MB (new in Orthanc 1.11.3)
     *
     * @return self
     */
    public function setMaximumStorageSize($maximumStorageSize)
    {
        if (is_null($maximumStorageSize)) {
            throw new \InvalidArgumentException('non-nullable maximumStorageSize cannot be null');
        }
        $this->container['maximumStorageSize'] = $maximumStorageSize;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The name of the Orthanc server, cf. the `Name` configuration option
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets overwriteInstances
     *
     * @return bool|null
     */
    public function getOverwriteInstances()
    {
        return $this->container['overwriteInstances'];
    }

    /**
     * Sets overwriteInstances
     *
     * @param bool|null $overwriteInstances Whether instances are overwritten when re-ingested (new in Orthanc 1.11.0)
     *
     * @return self
     */
    public function setOverwriteInstances($overwriteInstances)
    {
        if (is_null($overwriteInstances)) {
            throw new \InvalidArgumentException('non-nullable overwriteInstances cannot be null');
        }
        $this->container['overwriteInstances'] = $overwriteInstances;

        return $this;
    }

    /**
     * Gets pluginsEnabled
     *
     * @return bool|null
     */
    public function getPluginsEnabled()
    {
        return $this->container['pluginsEnabled'];
    }

    /**
     * Sets pluginsEnabled
     *
     * @param bool|null $pluginsEnabled Whether Orthanc was built with support for plugins
     *
     * @return self
     */
    public function setPluginsEnabled($pluginsEnabled)
    {
        if (is_null($pluginsEnabled)) {
            throw new \InvalidArgumentException('non-nullable pluginsEnabled cannot be null');
        }
        $this->container['pluginsEnabled'] = $pluginsEnabled;

        return $this;
    }

    /**
     * Gets storageAreaPlugin
     *
     * @return string|null
     */
    public function getStorageAreaPlugin()
    {
        return $this->container['storageAreaPlugin'];
    }

    /**
     * Sets storageAreaPlugin
     *
     * @param string|null $storageAreaPlugin Information about the installed storage area plugin (`null` if no such plugin is installed)
     *
     * @return self
     */
    public function setStorageAreaPlugin($storageAreaPlugin)
    {
        if (is_null($storageAreaPlugin)) {
            throw new \InvalidArgumentException('non-nullable storageAreaPlugin cannot be null');
        }
        $this->container['storageAreaPlugin'] = $storageAreaPlugin;

        return $this;
    }

    /**
     * Gets storageCompression
     *
     * @return bool|null
     */
    public function getStorageCompression()
    {
        return $this->container['storageCompression'];
    }

    /**
     * Sets storageCompression
     *
     * @param bool|null $storageCompression Whether storage compression is enabled (new in Orthanc 1.11.0)
     *
     * @return self
     */
    public function setStorageCompression($storageCompression)
    {
        if (is_null($storageCompression)) {
            throw new \InvalidArgumentException('non-nullable storageCompression cannot be null');
        }
        $this->container['storageCompression'] = $storageCompression;

        return $this;
    }

    /**
     * Gets userMetadata
     *
     * @return object|null
     */
    public function getUserMetadata()
    {
        return $this->container['userMetadata'];
    }

    /**
     * Sets userMetadata
     *
     * @param object|null $userMetadata The configured UserMetadata (new in Orthanc 1.12.0)
     *
     * @return self
     */
    public function setUserMetadata($userMetadata)
    {
        if (is_null($userMetadata)) {
            throw new \InvalidArgumentException('non-nullable userMetadata cannot be null');
        }
        $this->container['userMetadata'] = $userMetadata;

        return $this;
    }

    /**
     * Gets version
     *
     * @return string|null
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param string|null $version Version of Orthanc
     *
     * @return self
     */
    public function setVersion($version)
    {
        if (is_null($version)) {
            throw new \InvalidArgumentException('non-nullable version cannot be null');
        }
        $this->container['version'] = $version;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


